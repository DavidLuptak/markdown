% \iffalse
%<*driver>
\documentclass{ltxdockit}
\usepackage{btxdockit}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[american]{babel}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{blindtext}
\let\blindtext\relax % TODO: Remove these.
\let\Blindtext\relax
\usepackage{hologo}
\usepackage{xcolor}
\usepackage{doc}

% Set up the style.
\setcounter{secnumdepth}{4}
\addtokomafont{title}{\sffamily}
\addtokomafont{paragraph}{\spotcolor}
\addtokomafont{section}{\spotcolor}
\addtokomafont{subsection}{\spotcolor}
\addtokomafont{subsubsection}{\spotcolor}
\addtokomafont{descriptionlabel}{\spotcolor}
\setkomafont{caption}{\bfseries\sffamily\spotcolor}
\setkomafont{captionlabel}{\bfseries\sffamily\spotcolor}
\hypersetup{citecolor=spot}
\let\oldCodelineNo\theCodelineNo
\def\theCodelineNo{\textcolor{gray}{\oldCodelineNo}}

% Define some markup.
\let\pkg\relax % A package name
\newcommand\mdef[1]{% A TeX macro definition
  \phantomsection\label{macro:#1}\textcolor{spot}{\cs{#1}}}
\newcommand\m[1]{% A TeX macro reference
  \hyperref[macro:#1]{\textcolor{spot}{\cs{#1}}}}
\newcommand\luamdef[1]{% A Lua object / method definition
  \phantomsection\label{lua:#1}\textcolor{spot}{\t`#1`}}
\newcommand\luam[1]{% A Lua object / method reference
  \hyperref[lua:#1]{\t`#1`}}
\def\t`#1`{% Inline code
  \textcolor{spot}{\text{\texttt{#1}}}}
\newcommand\Optitem[2][]{% An option item definition
  \phantomsection\label{opt:#2}\optitem[#1]{#2}}
\newcommand\Valitem[2][]{% A value item definition
  \phantomsection\label{opt:#2}\valitem[#1]{#2}}
\newcommand\Opt[1]{% An option / value item reference
  \hyperref[opt:#1]{\t`#1`}}
\newcommand\acro[1]{% An acronym
  \textsc{#1}}

% Set up the catcodes.
\catcode`\_=12 % We won't be typesetting math and Lua contains lots of `_`.

% Set up the title page.
\titlepage{%
  title={A Markdown Interpreter for \TeX{}},
  subtitle={},
  url={https://github.com/witiko/markdown},
  author={Vít Novotný (based on the work of John MacFarlane and Hans Hagen)},
  email={witiko@mail.muni.cz},
  revision={1.0.0},
  date={\today}}
\CodelineIndex

% Set up the bibliography.
\usepackage{filecontents}
\begin{filecontents}{markdown.bib}
  @book{luatex16,
    author  = {{Lua\TeX{} development team}},
    title   = {Lua\TeX{} reference manual (0.95.0)},
    url     = {http://www.luatex.org/svn/trunk/manual/luatex.pdf},
    urldate = {2016-05-12}}
  @book{ierusalimschy13,
    author    = {Ierusalimschy, Roberto},
    year      = {2013},
    title     = {Programming in Lua},
    edition   = {3},
    isbn      = {978-85-903798-5-0},
    pagetotal = {xviii, 347},
    location  = {Rio de Janeiro},
    publisher = {PUC-Rio}}
\end{filecontents}
\usepackage[
  backend=biber,
  style=iso-numeric,
  sorting=none,
  autolang=other,
  sortlocale=auto]{biblatex}
\addbibresource{markdown.bib}

\begin{document}
  \printtitlepage
  \tableofcontents
  \DocInput{markdown.dtx}
  \printbibliography
\end{document}
%</driver>
% \fi
%
% \section{Introduction}
% This document is a reference manual for the \pkg{Markdown} package. It is
% split into three sections. This section explains the purpose and the
% background of the package and outlines its prerequisites. Section
% \ref{sec:interfaces} describes the interfaces exposed by the package along
% with usage notes and examples. It is aimed at the user of the package.
% Section \ref{sec:implementation} then describes the implementation of the
% package and is aimed at the developer of the package, as well as the curious
% users.
%
% \subsection{About \pkg{Markdown}}
% The \pkg{Markdown} package provides facilities the conversion of markdown
% markup to \TeX{}. These are provided both in form of a Lua module and in form
% of a plain \TeX{}, \LaTeX{}, and \Hologo{ConTeXt} macro packages that enable
% the direct inclusion of markdown documents inside \TeX{} documents.
%
% Architecturally, the package consists of the \pkg{Lunamark} Lua module by
% John MacFarlane, which was slimmed down and rewritten for the needs of the
% package. \pkg{Lunamark} provides speedy markdown parsing for the rest of the
% package and is stored inside the \t`markdown.lua` file. On top of
% \pkg{Lunamark} sits code for the plain \TeX{}, \LaTeX{}, and \Hologo{ConTeXt}
% formats by Vít Novotný.
%
% \iffalse
%<*lua>
% \fi
%  \begin{macrocode}
if not modules then modules = { } end modules ['markdown-lunamark'] = {
    version   = "0.4.0",
    comment   = "A module for the conversion from markdown to TeX",
    author    = "John MacFarlane, Hans Hagen, Vít Novotný",
    copyright = "2009-2016 John MacFarlane, Hans Hagen; 2016 Vít Novotný",
    license   = "MIT sublicensed as LPPL 1.3"
}
%    \end{macrocode}
%
% \subsection{Feedback}
% Please use the \pkg{markdown} project page on
% GitHub\footnote{\url{https://github.com/witiko/markdown/issues}} to report
% bugs and submit feature requests. Before making a feature request, please
% ensure that you have thoroughly studied this manual. If you do not want to
% report a bug or request a feature but are simply in need of assistance, you
% might want to consider posting your question on the \TeX-\LaTeX{} Stack
% Exchange\footnote{\url{http://tex.stackexchange.com}}.
%
% \subsection{Acknowledgements}
% I would like to thank the Faculty of Informatics at the Masaryk University in
% Brno for providing me with the opportunity to work on this package alongside
% my studies. I would also like to thank the creator of the Lunamark Lua
% module, John Macfarlane, for releasing Lunamark under a permissive license
% that enabled its inclusion into the package.
%
% The plain \TeX, \LaTeX, and \Hologo{ConTeXt} code draws inspiration from
% several sources including the source code of \Hologo{LaTeX2e}, the
% \pkg{minted} package by Geoffrey M. Poore -- which likewise tackles the issue
% of interfacing with an external interpreter from \TeX, and others.
%
% \subsection{Prerequisites}
% This section gives an overview of all resources required by the package.
%
% \subsubsection{Lua prerequisites}
% The Lua part of the package requires the following Lua modules:
% \begin{description}
%   \item[\pkg{LPeg}] A pattern-matching library for the writing of recursive
%     descent parsers via the Parsing Expression Grammars (\acro{peg}s). It is
%     used by the \pkg{Lunamark} library to parse the markdown input.
%  \begin{macrocode}
local lpeg = require("lpeg")
%    \end{macrocode}
%   \item[\pkg{Selene Unicode}] A library that provides support for the
%     processing of wide strings. It is used by the \pkg{Lunamark} library to
%     cast image, link, and footnote tags to the lower case.
%  \begin{macrocode}
local unicode = require("unicode")
%    \end{macrocode}
%   \item[\pkg{MD5}] A library that provides \acro{md5} crypto functions. It is
%     used by the \pkg{Lunamark} library to compute the digest of the input for
%     caching purposes. 
%  \begin{macrocode}
local md5 = require("md5")
%    \end{macrocode}
% \end{description}
% All the abovelisted modules are statically linked into the Lua\TeX{} engine
% (see \cite[Section~3.3]{luatex16}).
%
% \subsubsection{Plain \TeX{} prerequisites}
% The plain \TeX{} part of the package requires the following Lua module:
% \begin{description}
%   \item[\pkg{Lua File System}] A library that provides access to the
%     filesystem via \acro{os}-specific syscalls. It is used by the plain
%     \TeX{} code to create the cache directory specified by the
%     \m{markdownOptionCacheDir} macro before interfacing with the
%     \pkg{Lunamark} library.
%
%     The plain \TeX{} code makes use of the \luam{isDir} method that was added
%     to the module by the Lua\TeX{} engine developers (see
%     \cite[Section~3.2]{luatex16}). This method is not present in the base
%     library.
% \end{description}
% The \pkg{Lua File System} module is statically linked into the Lua\TeX{}
% engine (see \cite[Section~3.3]{luatex16}).
%
% The \TeX{} part of the package also requires that the plain format is loaded
% and that either the Lua\TeX{} \m{directlua} primitive or the \hologo{pdfTeX}
% shell access file stream 18 is available for the definition of the
% \m{markdownLuaExecute} macro.
%
% \subsubsection{\LaTeX{} prerequisites}
% \blindtext
%
% \subsubsection{\Hologo{ConTeXt} prerequisites}
% \blindtext
%
% \section{User Guide}\label{sec:interfaces}
% This part of the manual describes the interfaces exposed by the package
% along with usage notes and examples. It is aimed at the user of the package.
%
% \subsection{Lua Interface}\label{sec:luainterface}
% The Lua interface provides the conversion from markdown to \TeX{}.  This
% interface is used by the plain \TeX{} implementation (see Section
% \ref{sec:teximplementation}) and will be of interest to the developers of
% other packages and Lua modules.
%
% The Lua interface is implemented by the \t`markdown` Lua module.
%
%  \begin{macrocode}
local M = {}
%    \end{macrocode}
%
% \subsubsection{Conversion from Markdown to \TeX{}}\label{sec:luaconversion}
% The Lua interface exposes the \luamdef{converter} object. This object creates
% converter functions that perform the conversion from markdown to \TeX{}.
%
% A converter function can be created via the \luam{converter}\t`.new(options)`
% factory method, where \t`options` is a table of Lua options (see Section
% \ref{sec:luaoptions}). The \t`options` parameter is optional; when
% unspecified, the behaviour will be the same as if \t`options` were an empty
% table.
%  \begin{macrocode}
M.converter = {}
%    \end{macrocode}
%
% The following example Lua code converts the markdown string \t`_Hello
% world!_` to a \TeX{} output using the default options and prints the \TeX{}
% output:
% \begin{verbatim}
% local md = require("markdown")
% local convert = md.converter.new()
% print(convert("_Hello world!_"))\end{verbatim}
%
% \subsubsection{Options}\label{sec:luaoptions}
% The Lua interface recognizes the following options:
%  \begin{macrocode}
local defaultOptions = {}
%    \end{macrocode}
% \begin{optionlist}
%   \Optitem[false]{blankBeforeBlockquote}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Require a blank line between a paragraph and the following
%         blockquote.
%       \item[false] Do not require a blank line between a paragraph and the
%         following blockquote.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.blankBeforeBlockquote = false
%    \end{macrocode}
%
%   \Optitem[false]{blankBeforeHeading}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Require a blank line between a paragraph and the following
%         header.
%       \item[false] Do not require a blank line between a paragraph and the
%         following header.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.blankBeforeHeading = false
%    \end{macrocode}
%
%   \Valitem[.]{cacheDir}{directory}
%     The path to the directory containing auxiliary cache files.
%  \begin{macrocode}
defaultOptions.cacheDir = "."
%    \end{macrocode}
%
%   \Optitem[false]{definitionLists}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Enable the pandoc definition list syntax extension:
%         \begin{verbatim}
% Term 1
% 
% :   Definition 1
% 
% Term 2 with *inline markup*
% 
% :   Definition 2
% 
%         { some code, part of Definition 2 }
% 
%     Third paragraph of definition 2.\end{verbatim}
%       \item[false] Disable the pandoc definition list syntax extension.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.definitionLists = false
%    \end{macrocode}
% 
%   \Optitem[false]{hashEnumerator}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Enable the use of hash symbols (\t`\#`) as ordered item
%         list markers.
%       \item[false] Disable the use of hash symbols (\t`\#`) as ordered item
%         list markers.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.hashEnumerator = false
%    \end{macrocode}
%
%   \Optitem[false]{hybrid}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Disable the escaping of special plain \TeX{} characters,
%         which makes it possible to intersperse your markdown markup with
%         \TeX{} code. The intended usage is in documents prepared manually by
%         a human author.  In such documents, it can often be desirable to mix
%         \TeX{} and markdown markup freely.
%
%       \item[false] Enable the escaping of special plain \TeX{} characters
%         outside verbatim environments, so that they are not interpretted by
%         \TeX{}. This is encouraged when typesetting automatically generated
%         content or markdown documents that were not prepared with this
%         package in mind.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.hybrid = false
%    \end{macrocode}
%
%   \Optitem[false]{notes}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Enable the pandoc footnote syntax extension:
%         \begin{verbatim}
% Here is a footnote reference,[^1] and another.[^longnote]
% 
% [^1]: Here is the footnote.
% 
% [^longnote]: Here's one with multiple blocks.
% 
%     Subsequent paragraphs are indented to show that they
% belong to the previous footnote.
% 
%         { some.code }
% 
%     The whole paragraph can be indented, or just the first
%     line.  In this way, multi-paragraph footnotes work like
%     multi-paragraph list items.
% 
% This paragraph won't be part of the note, because it
% isn't indented.\end{verbatim}
%       \item[false] Disable the pandoc footnote syntax extension.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.notes = false
%    \end{macrocode}
%
%   \Optitem[false]{preserveTabs}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Preserve all tabs in the input.
%       \item[false] Convert any tabs in the input to spaces.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.preserveTabs = false
%    \end{macrocode}
%
%   \Optitem[false]{smartEllipses}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Convert any ellipses in the input to the
%         \m{markdownRendererEllipsis} \TeX{} macro.
%       \item[false] Preserve all ellipses in the input.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.smartEllipses = false
%    \end{macrocode}
%
%   \Optitem[true]{startNumber}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Make the number in the first item in ordered lists
%         significant. The number of each item will be passed to the
%         \m{markdownRendererOlItemWithNumber} \TeX{} macro.
%       \item[false] Ignore the number in the items of ordered lists. Each
%         item will only produce a \m{markdownRendererOlItem} \TeX{} macro.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.startNumber = true
%    \end{macrocode}
%
%   \Optitem[true]{verbatim}{\opt{true}, \opt{false}}
%     \begin{valuelist}
%       \item[true] Store the contents of all code blocks in temporary files
%         inside the cache directory. The filename containing the contents of a
%         corresponding code block will be passed to the
%         \m{markdownRendererInputVerbatim} \TeX{} macro.
%       \item[false] Surround all code blocks with the
%         \m{markdownRendererCodeBlockBegin} and
%         \m{markdownRendererCodeBlockEnd} \TeX{} macros and escape any special
%         \TeX{} characters inside their contents.
%     \end{valuelist}
%  \begin{macrocode}
defaultOptions.verbatim = true
%    \end{macrocode}
% \end{optionlist}
% 
% \iffalse
%</lua>
%<*tex>
% \fi\subsection{Plain \TeX{} Interface}\label{sec:texinterface}
% The plain \TeX{} interface provides macros for the conversion from markdown
% to \TeX{} from within \TeX{} with the Lua options (see Section
% \ref{sec:luaoptions}) and the way markdown tokens are rendered exposed as
% \TeX{} macros.
%
% The plain \TeX{} interface is implemented by the \t`markdown.tex` file. It is
% expected that at least some of the basic characters that make up the syntax
% of plain \TeX{} (\t`\textbackslash\{\}\#\%\textvisiblespace`) have the
% expected category codes, when \m{input}ting the file.
%
% \subsubsection{Conversion from Markdown to \TeX{}}
% The interface exposes the \mdef{markdownBegin}, \mdef{markdownEnd}, and
% \mdef{markdownInput} macros.
%
% The \m{markdownBegin} macro marks the beginning of a markdown document
% fragment. The corresponding \m{markdownEnd} macro must be visible directly
% from the input line buffer (it may not be produced as a result of input
% expansion); it will otherwise not be recognized as the end of the markdown
% string.
%  \begin{macrocode}
\let\markdownBegin\relax
\let\markdownEnd\relax
%    \end{macrocode}
% Note that the macros will consume the rest of the lines at which they appear.
% In the following example plain \TeX{} code, the characters \t`c` and \t`f`
% will not appear in the output.
% \begin{verbatim}
% \input markdown
% a
% b \markdownBegin c 
% d 
% e \markdownEnd   f
% g 
% \bye\end{verbatim}
%
% The \m{markdownInput} macro accepts a single parameter containing the
% filename of a markdown document and expands to the result of the conversion
% of the input markdown document to \TeX{}.
%  \begin{macrocode}
\let\markdownInput\relax
%    \end{macrocode}
%
% The following example \TeX{} code produces a document containing the result
% of the conversion of the markdown string \t`_Hello world!_` two times,
% supposing that the \t`hello.md` file contains the \t`_Hello world!_`
% string.
% \begin{verbatim}
% \input markdown
% \markdownBegin
%   _Hello world!_
% \markdownEnd
% \markdownInput{hello.md}
% \bye\end{verbatim}
%
% \subsubsection{Options}\label{sec:texoptions}
% The plain \TeX{} options are represented by \TeX{} macros. Some of them map
% directly to the options recognized by the Lua interface (see Section
% \ref{sec:luaoptions}), while some of them are specific to the plain \TeX{}
% interface.
%
% \paragraph{File and directory names}
% The \mdef{markdownOptionHelperScriptFileName} macro sets the filename of the
% helper Lua script file that is created during the conversion from markdown to
% \TeX{} in \TeX{} engines without the \m{directLua} primitive. It defaults to
% \m{jobname}\t`.markdown.lua`, where \m{jobname} is the base name of the
% document being typeset.
%
% The expansion of this macro must not contain quotation marks (\t`"`) or
% backslash symbols (\t`\textbackslash`). Mind that \TeX{} engines tend to
% put quotation marks around \m{jobname}, when it contains spaces.
%  \begin{macrocode}
\def\markdownOptionHelperScriptFileName{\jobname.markdown.lua}%
%    \end{macrocode}
%
% The \mdef{markdownOptionInputTempFileName} macro sets the filename of the
% temporary input file that is created during the conversion from markdown to
% \TeX{} in \TeX{} engines without the \m{directLua} primitive. It defaults to
% \m{jobname}\t`.markdown.out`. The same limitations as in the case of the
% \m{markdownOptionHelperScriptFileName} macro apply here.
%  \begin{macrocode}
\def\markdownOptionInputTempFileName{\jobname.markdown.in}%
%    \end{macrocode}
%
% The \mdef{markdownOptionOutputTempFileName} macro sets the filename of the
% temporary output file that is created during the conversion from markdown to
% \TeX{} in \TeX{} engines without the \m{directLua} primitive. It defaults to
% \m{jobname}\t`.markdown.out`. The same limitations as in the case of the
% \m{markdownOptionHelperScriptFileName} macro apply here.
%  \begin{macrocode}
\def\markdownOptionOutputTempFileName{\jobname.markdown.out}%
%    \end{macrocode}
%
% The \mdef{markdownOptionCacheDir} macro corresponds to the Lua interface
% \Opt{cacheDir} option that sets the name of the directory that will contain
% the produced cache files. The option defaults to \t`_markdown-`\m{jobname},
% which is a similar naming scheme to the one used by the \pkg{minted} \LaTeX{}
% package. The same limitations as in the case of the
% \m{markdownOptionHelperScriptFileName} macro apply here.
%  \begin{macrocode}
\def\markdownOptionCacheDir{_markdown-\jobname}%
%    \end{macrocode}
%
% \paragraph{Lua Wrappers}
% The following macros map directly to the options recognized by the Lua
% interface (see Section \ref{sec:luaoptions}) and are not processed by the
% plain \TeX{} implementation, only passed along to Lua. They are undefined, which
% makes them fall back to the default values provided by the Lua interface.
%  \begin{macrocode}
\let\markdownOptionBlankBeforeBlockquote\undefined
\let\markdownOptionBlankBeforeHeading\undefined
\let\markdownOptionDefinitionLists\undefined
\let\markdownOptionHashEnumerator\undefined
\let\markdownOptionHybrid\undefined
\let\markdownOptionNotes\undefined
\let\markdownOptionPreserveTabs\undefined
\let\markdownOptionSmartEllipses\undefined
\let\markdownOptionStartNumber\undefined
\let\markdownOptionVerbatim\undefined
%    \end{macrocode}
%
% \paragraph{Miscellaneous}
% The \m{markdownOptionFileStream} macro may contain the file stream number the
% plain \TeX{} implementation should use when accessing temporary files during
% the conversion from markdown to \TeX{} in \TeX{} engines without the
% \m{directLua} primitive. This macro must be defined prior to \m{input}ting
% the \t`markdown.tex` file. Otherwise a new file stream number will be
% allocated.
%  \begin{macrocode}
\ifx\markdownOptionFileStream\undefined
  \newwrite\markdownOptionFileStream
\fi
%    \end{macrocode}
%
% \subsubsection{Token Renderers}\label{sec:texrenderersuser}
% The following \TeX{} macros may occur inside the output of the
% converter functions exposed by the Lua interface (see Section
% \ref{sec:luaconversion}) and represent the parsed markdown tokens. These
% macros are intended to be redefined by the user who is typesetting a
% document. By default, they point to the corresponding prototypes (see Section
% \ref{sec:texrenderersprototypes}).
%
% \paragraph{Ellipsis Renderer}
% The \mdef{markdownRendererEllipsis} macro replaces any occurance of ASCII
% ellipses in the input text. This macro will only be produced, when the
% \Opt{smartEllipses} option is \t`true`.  The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererEllipsis{%
  \markdownRendererEllipsisPrototype}%
%    \end{macrocode}
%
% \paragraph{Code Span Renderer}
% The \mdef{markdownRendererCodeSpan} macro represents inlined code in the
% input text. It receives a single argument that corresponds to the inlined
% code.
%  \begin{macrocode}
\def\markdownRendererCodeSpan{%
  \markdownRendererCodeSpanPrototype}%
%    \end{macrocode}
%
% \paragraph{Link Renderer}
% The \mdef{markdownRendererLink} macro represents a hyperlink. It receives
% three arguments: the label, the \acro{url}, and the title of the link.
%  \begin{macrocode}
\def\markdownRendererLink{%
  \markdownRendererLinkPrototype}%
%    \end{macrocode}
%
% \paragraph{Image Renderer}
% The \mdef{markdownRendererImage} macro represents an image. It receives three
% arguments: the label, the \acro{url}, and the title of the image.
%  \begin{macrocode}
\def\markdownRendererImage{%
  \markdownRendererImagePrototype}%
%    \end{macrocode}
%
% \paragraph{Bullet List Renderers}
% The \mdef{markdownRendererUlBegin} macro represents the beginning of a bullet
% list that contains an item with several paragraphs of text (the list is not
% tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererUlBegin{%
  \markdownRendererUlBeginPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererUlBeginTight} macro represents the beginning of a
% bullet list that contains no item with several paragraphs of text (the list
% is tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererUlBeginTight{%
  \markdownRendererUlBeginTightPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererUlItem} macro represents an item in a bullet list.
% The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererUlItem{%
  \markdownRendererUlItemPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererUlEnd} macro represents the end of a bullet list
% that contains an item with several paragraphs of text (the list is not
% tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererUlEnd{%
  \markdownRendererUlEndPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererUlEndTight} macro represents the end of a bullet
% list that contains no item with several paragraphs of text (the list is
% tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererUlEndTight{%
  \markdownRendererUlEndTightPrototype}%
%    \end{macrocode}
%
% \paragraph{Ordered ListRenderers}
% The \mdef{markdownRendererOlBegin} macro represents the beginning of an
% ordered list that contains an item with several paragraphs of text (the
% list is not tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererOlBegin{%
  \markdownRendererOlBeginPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererOlBeginTight} macro represents the beginning of an
% ordered list that contains no item with several paragraphs of text (the
% list is tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererOlBeginTight{%
  \markdownRendererOlBeginTightPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererOlItem} macro represents an item in an ordered list.
% This macro will only be produced, when the \Opt{startNumber} option is
% \t`false`.  The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererOlItem{%
  \markdownRendererOlItemPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererOlItemWithNumber} macro represents an item in an
% ordered list.  This macro will only be produced, when the \Opt{startNumber}
% option is \t`true`.  The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererOlItemWithNumber{%
  \markdownRendererOlItemWithNumberPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererOlEnd} macro represents the end of an ordered list
% that contains an item with several paragraphs of text (the list is not
% tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererOlEnd{%
  \markdownRendererOlEndPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererOlEndTight} macro represents the end of an ordered
% list that contains no item with several paragraphs of text (the list is
% tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererOlEndTight{%
  \markdownRendererOlEndTightPrototype}%
%    \end{macrocode}
%
% \paragraph{Definition List Renderers}
% The following macros are only produces, when the \Opt{definitionLists} option
% is \t`true`.
%
% The \mdef{markdownRendererDlBegin} macro represents the beginning of a
% definition list that contains an item with several paragraphs of text (the
% list is not tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererDlBegin{%
  \markdownRendererDlBeginPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererDlBeginTight} macro represents the beginning of a
% definition list that contains an item with several paragraphs of text (the
% list is not tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererDlBeginTight{%
  \markdownRendererDlBeginTightPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererDlItem} macro represents an item in a definition
% list. The macro receives a single argument that corresponds to the term being
% defined.
%  \begin{macrocode}
\def\markdownRendererDlItem{%
  \markdownRendererDlItemPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererDlEnd} macro represents the end of a definition
% list that contains an item with several paragraphs of text (the list is not
% tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererDlEnd{%
  \markdownRendererDlEndPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererDlEndTight} macro represents the end of a
% definition list that contains no item with several paragraphs of text (the
% list is tight). The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererDlEndTight{%
  \markdownRendererDlEndTightPrototype}%
%    \end{macrocode}
%
% \paragraph{Emphasis Renderers}
% The \mdef{markdownRendererEmphasis} macro represents an emphasized span of
% text. The macro receives a single argument that corresponds to the emphasized
% span of text.
%  \begin{macrocode}
\def\markdownRendererEmphasis{%
  \markdownRendererEmphasisPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererStrongEmphasis} macro represents a strongly
% emphasized span of text. The macro receives a single argument that
% corresponds to the emphasized span of text.
%  \begin{macrocode}
\def\markdownRendererStrongEmphasis{%
  \markdownRendererStrongEmphasisPrototype}%
%    \end{macrocode}
%
% \paragraph{Block Quote Renderers}
% The \mdef{markdownRendererBlockQuoteBegin} macro represents the beginning of
% a block quote. The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererBlockQuoteBegin{%
  \markdownRendererBlockQuoteBeginPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererBlockQuoteEnd} macro represents the end of a block
% quote. The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererBlockQuoteEnd{%
  \markdownRendererBlockQuoteEndPrototype}%
%    \end{macrocode}
%
% \paragraph{Code Block Renderers}
% The \mdef{markdownRendererCodeBlockBegin} macro represents the beginning of a
% code block. This macro will only be produced, when the \Opt{verbatim} option
% is \t`false`. The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererCodeBlockBegin{%
  \markdownRendererCodeBlockBeginPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererCodeBlockEnd} macro represents the end of a code
% block. This macro will only be produced, when the \Opt{verbatim} option is
% \t`false`. The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererCodeBlockEnd{%
  \markdownRendererCodeBlockEndPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererInputVerbatim} macro represents a code
% block. This macro will only be produced, when the \Opt{verbatim} option is
% \t`true`. The macro receives a single argument that corresponds to the
% filename of a file contaning the code block to input.
%  \begin{macrocode}
\def\markdownRendererInputVerbatim{%
  \markdownRendererInputVerbatimPrototype}%
%    \end{macrocode}
%
% \paragraph{Heading Renderers}
% The \mdef{markdownRendererHeadingOne} macro represents a first level heading.
% The macro receives a single argument that corresponds to the heading text.
%  \begin{macrocode}
\def\markdownRendererHeadingOne{%
  \markdownRendererHeadingOnePrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererHeadingTwo} macro represents a second level
% heading. The macro receives a single argument that corresponds to the heading
% text.
%  \begin{macrocode}
\def\markdownRendererHeadingTwo{%
  \markdownRendererHeadingTwoPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererHeadingThree} macro represents a third level
% heading. The macro receives a single argument that corresponds to the heading
% text.
%  \begin{macrocode}
\def\markdownRendererHeadingThree{%
  \markdownRendererHeadingThreePrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererHeadingFour} macro represents a fourth level
% heading. The macro receives a single argument that corresponds to the heading
% text.
%  \begin{macrocode}
\def\markdownRendererHeadingFour{%
  \markdownRendererHeadingFourPrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererHeadingFive} macro represents a fifth level
% heading. The macro receives a single argument that corresponds to the heading
% text.
%  \begin{macrocode}
\def\markdownRendererHeadingFive{%
  \markdownRendererHeadingFivePrototype}%
%    \end{macrocode}
%
% The \mdef{markdownRendererHeadingSix} macro represents a sixth level
% heading. The macro receives a single argument that corresponds to the heading
% text.
%  \begin{macrocode}
\def\markdownRendererHeadingSix{%
  \markdownRendererHeadingSixPrototype}%
%    \end{macrocode}
%
% \paragraph{Horizontal Rule Renderer}
% The \mdef{markdownRendererHorizontalRule} macro represents a horizontal rule.
% The macro receives no arguments.
%  \begin{macrocode}
\def\markdownRendererHorizontalRule{%
  \markdownRendererHorizontalRulePrototype}%
%    \end{macrocode}
%
% \paragraph{Footnote Renderer}
% The \mdef{markdownRendererFootnote} macro represents a footnote. This macro
% will only be produced, when the \Opt{notes} option is \t`true`.  The macro
% receives a single argument that corresponds to the footnote text.
%  \begin{macrocode}
\def\markdownRendererFootnote{%
  \markdownRendererFootnotePrototype}%
%    \end{macrocode}
%
% \subsubsection{Token Renderer Prototypes}\label{sec:texrenderersprototypes}
% The following \TeX{} macros provide definitions for the token renderers (see
% Section \ref{sec:texrenderersuser}) that have not been redefined by the
% user. These macros are intended to be redefined by macro package authors
% who wish to provide sensible default token renderers. They are also redefined
% by the \LaTeX{} and \Hologo{ConTeXt} implementations (see sections
% \ref{sec:lateximplementation} and \ref{sec:contextimplementation}).
%
%  \begin{macrocode}
\def\markdownRendererEllipsisPrototype{...}%
\def\markdownRendererCodeSpanPrototype#1{{\tt#1}}%
\def\markdownRendererLinkPrototype#1#2#3{#1}%
\def\markdownRendererImagePrototype#1#2#3{#1}%
\def\markdownRendererUlBeginPrototype{}%
\def\markdownRendererUlBeginTightPrototype{}%
\def\markdownRendererUlItemPrototype{}%
\def\markdownRendererUlEndPrototype{}%
\def\markdownRendererUlEndTightPrototype{}%
\def\markdownRendererOlBeginPrototype{}%
\def\markdownRendererOlBeginTightPrototype{}%
\def\markdownRendererOlItemPrototype{}%
\def\markdownRendererOlItemWithNumberPrototype#1{}%
\def\markdownRendererOlEndPrototype{}%
\def\markdownRendererOlEndTightPrototype{}%
\def\markdownRendererDlBeginPrototype{}%
\def\markdownRendererDlBeginTightPrototype{}%
\def\markdownRendererDlItemPrototype#1{#1}%
\def\markdownRendererDlEndPrototype{}%
\def\markdownRendererDlEndTightPrototype{}%
\def\markdownRendererEmphasisPrototype#1{{\it#1}}%
\def\markdownRendererStrongEmphasisPrototype#1{{\it#1}}%
\def\markdownRendererBlockQuoteBeginPrototype{\par\begingroup\it}%
\def\markdownRendererBlockQuoteEndPrototype{\endgroup\par}%
\def\markdownRendererCodeBlockBeginPrototype{\par\begingroup\tt}%
\def\markdownRendererCodeBlockEndPrototype{\endgroup\par}%
\def\markdownRendererInputVerbatimPrototype#1{\par{\tt\input{#1}}\par}%
\def\markdownRendererHeadingOnePrototype#1{#1}%
\def\markdownRendererHeadingTwoPrototype#1{#1}%
\def\markdownRendererHeadingThreePrototype#1{#1}%
\def\markdownRendererHeadingFourPrototype#1{#1}%
\def\markdownRendererHeadingFivePrototype#1{#1}%
\def\markdownRendererHeadingSixPrototype#1{#1}%
\def\markdownRendererHorizontalRulePrototype{}%
\def\markdownRendererFootnotePrototype#1{#1}%
%    \end{macrocode}
%
% \iffalse
%</tex>
%<*latex>
% \fi\subsection{\LaTeX{} Interface}\label{sec:latexinterface}
% \blindtext
%
% \iffalse
%</latex>
%<*context>
% \fi\subsection{\Hologo{ConTeXt} Interface}\label{sec:contextinterface}
% \blindtext
% 
% \section{Technical Documentation}\label{sec:implementation}
% This part of the manual describes the implementation of the interfaces
% exposed by the package (see Section \ref{sec:interfaces}) and is aimed at the
% developers of the package, as well as the curious users.
%
% \iffalse
%</context>
%<*lua>
% \fi\subsection{Lua Implementation}\label{sec:luaimplementation}
% The Lua implementation implements \luamdef{writer} and \luamdef{reader}
% objects that provide the conversion from markdown to \TeX{}.
%
% The Lunamark Lua module implements writers for the conversion to various
% other formats, such as DocBook, Groff, or \acro{HTML}. These were stripped
% from the module and the remaining markdown reader and \TeX{} writer were
% hidden behind the \luam{converter} object exposed by the Lua interface (see
% Section \ref{sec:luainterface}).
%
%  \begin{macrocode}
local upper, gsub, format, length =
  string.upper, string.gsub, string.format, string.len
local concat = table.concat
local P, R, S, V, C, Cg, Cb, Cmt, Cc, Ct, B, Cs, any =
  lpeg.P, lpeg.R, lpeg.S, lpeg.V, lpeg.C, lpeg.Cg, lpeg.Cb,
  lpeg.Cmt, lpeg.Cc, lpeg.Ct, lpeg.B, lpeg.Cs, lpeg.P(1)
%    \end{macrocode}
% 
% \subsubsection{Utility Functions}
% This section documents the utility functions used by the Lua code. These were
% originally located in the \t`lunamark/util.lua` file in the Lunamark library.
%  \begin{macrocode}
local util = {}
%    \end{macrocode}
% 
% The \luamdef{util.err} method prints an error message \t`msg` and exits.
% If \t`exit_code` is provided, it specifies the exit code.  Otherwise, the
% exit code will be 1.
%  \begin{macrocode}
function util.err(msg, exit_code)
  io.stderr:write("markdown.lua: " .. msg .. "\n")
  os.exit(exit_code or 1)
end
%    \end{macrocode}
%
% The \luamdef{util.cache} method computes the digest of \t`string` and
% \t`salt`, adds the \t`suffix` and looks into the directory \t`dir`, whether a
% file with such a name exists. If it does not, it gets created with
% \t`transform(string)` as its content. The filename is then returned.
%  \begin{macrocode}
function util.cache(dir, string, salt, transform, suffix)
  local digest = md5.sumhexa(string .. (salt or ""))
  local name = util.pathname(dir, digest .. suffix)
  local file = io.open(name, "r")
  if file == nil then -- If no cache entry exists, then create a new one.
    local file = assert(io.open(name, "w"))
    local result = string
    if transform ~= nil then
      result = transform(result)
    end
    assert(file:write(result))
    assert(file:close())
  end
  return name
end
%    \end{macrocode}
%
% The \luamdef{util.table_copy} method creates a shallow copy of a table \t`t`
% and its metatable.
%  \begin{macrocode}
function util.table_copy(t)
  local u = { }
  for k, v in pairs(t) do u[k] = v end
  return setmetatable(u, getmetatable(t))
end
%    \end{macrocode}
%
% The \luamdef{util.expand_tabs_in_line} expands tabs in string \t`s`. If
% \t`tabstop` is specified, it is used as the tab stop width. Otherwise,
% the tab stop width of 4 characters is used. The method is a copy of the tab
% expansion algorithm from \cite[Chapter~21]{ierusalimschy13}.
%  \begin{macrocode}
function util.expand_tabs_in_line(s, tabstop)
  local tab = tabstop or 4
  local corr = 0
  return (s:gsub("()\t", function(p)
            local sp = tab - (p - 1 + corr) % tab
            corr = corr - 1 + sp
            return string.rep(" ", sp)
          end))
end
%    \end{macrocode}
%
% The \luamdef{util.walk} method walks a rope \t`t`, applying a function \t`f`
% to each leaf element in order. A rope is an array whose elements may be
% ropes, strings, numbers, or functions.  If a leaf element is a function, call
% it and get the return value before proceeding.
%  \begin{macrocode}
function util.walk(t, f)
  local typ = type(t)
  if typ == "string" then
    f(t)
  elseif typ == "table" then
    local i = 1
    local n
    n = t[i]
    while n do
      util.walk(n, f)
      i = i + 1
      n = t[i]
    end
  elseif typ == "function" then
    local ok, val = pcall(t)
    if ok then
      util.walk(val,f)
    end
  else
    f(tostring(t))
  end
end
%    \end{macrocode}
%
% The \luamdef{util.flatten} method flattens an array \t`ary` that does not
% contain cycles and returns the result.
%  \begin{macrocode}
function util.flatten(ary)
  local new = {}
  for _,v in ipairs(ary) do
    if type(v) == "table" then
      for _,w in ipairs(util.flatten(v)) do
        new[#new + 1] = w
      end
    else
      new[#new + 1] = v
    end
  end
  return new
end
%    \end{macrocode}
%
% The \luamdef{util.rope_to_string} method converts a rope \t`rope` to a
% string and returns it. For the definition of a rope, see the definition of
% the \luam{util.walk} method.
%  \begin{macrocode}
function util.rope_to_string(rope)
  local buffer = {}
  util.walk(rope, function(x) buffer[#buffer + 1] = x end)
  return table.concat(buffer)
end
%    \end{macrocode}
%
% The \luamdef{util.rope_last} method retrieves the last item in a rope. For
% the definition of a rope, see the definition of the \luam{util.walk} method.
%  \begin{macrocode}
function util.rope_last(rope)
  if #rope == 0 then
    return nil
  else
    local l = rope[#rope]
    if type(l) == "table" then
      return util.rope_last(l)
    else
      return l
    end
  end
end
%    \end{macrocode}
%
% Given an array \t`ary` and a string \t`x`, the \luamdef{util.intersperse}
% method returns an array \t`new`, such that \t`ary[i] == new[2*(i-1)+1]` and
% \t`new[2*i] == x` for all $1\leq\t`i`\leq\t`\#ary`$.
%  \begin{macrocode}
function util.intersperse(ary, x)
  local new = {}
  local l = #ary
  for i,v in ipairs(ary) do
    local n = #new
    new[n + 1] = v
    if i ~= l then
      new[n + 2] = x
    end
  end
  return new
end
%    \end{macrocode}
% 
% Given an array \t`ary` and a function \t`f`, the \luamdef{util.map} method
% returns an array \t`new`, such that \t`new[i] == f(ary[i])` for all
% $1\leq\t`i`\leq\t`\#ary`$.
%  \begin{macrocode}
function util.map(ary, f)
  local new = {}
  for i,v in ipairs(ary) do
    new[i] = f(v)
  end
  return new
end
%    \end{macrocode}
%
% Given a table \t`char_escapes` mapping escapable characters to escaped
% strings and optionally a table \t`string_escapes` mapping escapable strings
% to escaped strings, the \luamdef{util.escaper} method returns a function that
% escapes all occurances of escapable strings and characters (in this order).
% 
% The method uses \pkg{LPeg}, which is faster than the Lua \t`string.gsub`
% built-in method.
%  \begin{macrocode}
function util.escaper(char_escapes, string_escapes)
%    \end{macrocode}
% Build a string of escapable characters.
%  \begin{macrocode}
  local char_escapes_list = ""
  for i,_ in pairs(char_escapes) do
    char_escapes_list = char_escapes_list .. i
  end
%    \end{macrocode}
% Create an \pkg{LPeg} capture \t`escapable` that produces the escaped string
% corresponding to the matched escapable character.
%  \begin{macrocode}
  local escapable = S(char_escapes_list) / char_escapes
%    \end{macrocode}
% If \t`string_escapes` is provided, turn \t`escapable` into the
% {\catcode`\_=8\[
%   \sum_{(\t`k`,\t`v`)\in\t`string\_escapes`}\t`P(k) / v` + \t`escapable`
% \]}^^A
% capture that replaces any occurance of the string \t`k` with the string
% \t`v` for each $(\t`k`, \t`v`)\in\t`string\_escapes`$. Note that the pattern
% summation is not commutative and the summation operands are inspected in the
% summation order during the matching. As a corrolary, the strings always take
% precedence over the characters.
%  \begin{macrocode}
  if string_escapes then
    for k,v in pairs(string_escapes) do
      escapable = P(k) / v + escapable
    end
  end
%    \end{macrocode}
% Create an \pkg{LPeg} capture \t`escape_string` that captures anything
% \t`escapable` does and matches any other unmatched characters.
%  \begin{macrocode}
  local escape_string = Cs((escapable + any)^0)
%    \end{macrocode}
% Return a function that matches the input string \t`s` against the
% \t`escape_string` capture.
%  \begin{macrocode}
  return function(s)
    return lpeg.match(escape_string, s)
  end
end
%    \end{macrocode}
%
% The \luamdef{util.pathname} method produces a pathname out of a directory
% name \t`dir` and a filename \t`file` and returns it.
%  \begin{macrocode}
function util.pathname(dir, file)
  if #dir == 0 then
    return file
  else
    return dir .. "/" .. file
  end
end
%    \end{macrocode}
% \subsubsection{\TeX{} Writer}\label{sec:texwriter}
% \blindtext
%
% Creates a new \TeX{} writer, where \t`options` is a table with options.
%  \begin{macrocode}
M.writer = {}
function M.writer.new(options)
  local self = {}
  options = options or {}
%    \end{macrocode}
% Inherit options from the \t`defaultOptions` table.
%  \begin{macrocode}
  setmetatable(options, { __index = function (_, key)
    return defaultOptions[key] end })
%    \end{macrocode}
% The suffix of the cached files.
%  \begin{macrocode}
  self.suffix = ".tex"
%    \end{macrocode}
% A space character.
%  \begin{macrocode}
  self.space = " "
%    \end{macrocode}
% The plain text block formatter.
%  \begin{macrocode}
  function self.plain(s)
    return s
  end
%    \end{macrocode}
% The paragraph formatter.
%  \begin{macrocode}
  function self.paragraph(s)
    return s
  end
%    \end{macrocode}
% Line breaks for use between block elements.
%  \begin{macrocode}
  self.interblocksep = "\n\n"
%    \end{macrocode}
% A line break.
%  \begin{macrocode}
  self.linebreak = "\\\\"
%    \end{macrocode}
% An ellipsis.
%  \begin{macrocode}
  self.ellipsis = "\\markdownRendererEllipsis "
%    \end{macrocode}
% The horizontal rule.
%  \begin{macrocode}
  self.hrule = "\\markdownRendererHorizontalRule "
%    \end{macrocode}
% A special character escaping function.
%  \begin{macrocode}
  self.escaped = {
     ["{"] = "\\{",
     ["}"] = "\\}",
     ["$"] = "\\$",
     ["%"] = "\\%",
     ["&"] = "\\&",
     ["_"] = "\\_",
     ["#"] = "\\#",
     ["^"] = "\\^{}",
     ["\\"] = "\\char92{}",
     ["~"] = "\\char126{}",
     ["|"] = "\\char124{}",
  }
  local escape = util.escaper(self.escaped)
  if options.hybrid then
    self.string = function(s) return s end
  else
    self.string = escape
  end
%    \end{macrocode}
% The inline verbatim code formatter.
%  \begin{macrocode}
  function self.code(s)
    return {"\\markdownRendererCodeSpan{",escape(s),"}"}
  end
%    \end{macrocode}
% A formatter for a link with the text \t`label`, the URI \t`uri`, and the
% title \t`title`.
%  \begin{macrocode}
  function self.link(lab,src,tit)
    return {"\\markdownRendererLink{",self.string(lab[1]),"}",
                          "{",self.string(src),"}",
                          "{",self.string(tit),"}"}
  end
%    \end{macrocode}
% A formatter for an image with the alternative text \t`label`, the source URI
% \t`src`, and the title \t`title`.
%  \begin{macrocode}
  function self.image(lab,src,tit)
    return {"\\markdownRendererImage{",self.string(lab[1]),"}",
                           "{",self.string(src),"}",
                           "{",self.string(tit),"}"}
  end
%    \end{macrocode}
% The formatter for a bullet list with contents \t`items` (an array).  If
% \t`tight` is true, the list should have minimal spacing between items.
%  \begin{macrocode}
  local function ulitem(s)
    return {"\\markdownRendererUlItem ",s}
  end

  function self.bulletlist(items,tight)
    local buffer = {}
    for _,item in ipairs(items) do
      buffer[#buffer + 1] = ulitem(item)
    end
    local contents = util.intersperse(buffer,"\n")
    if tight then
      return {"\\markdownRendererUlBeginTight\n",contents,
        "\n\\markdownRendererUlEndTight "}
    else
      return {"\\markdownRendererUlBegin\n",contents,
        "\n\\markdownRendererUlEnd "}
    end
  end
%    \end{macrocode}
% The formatter for an ordered list with contents \t`items` (an array). If
% \t`tight` is true, the list should have minimal spacing between items. If the
% optional number \t`num` is present, it should be used as the number of the
% first list item.
%  \begin{macrocode}
  local function olitem(s,num)
    if num ~= nil then
      return {"\\markdownRendererOlItemWithNumber{",num,"} ",s}
    else
      return {"\\markdownRendererOlItem ",s}
    end
  end

  function self.orderedlist(items,tight,startnum)
    local buffer = {}
    local num = startnum
    for _,item in ipairs(items) do
      buffer[#buffer + 1] = olitem(item,num)
      if num ~= nil then
        num = num + 1
      end
    end
    local contents = util.intersperse(buffer,"\n")
    if tight then
      return {"\\markdownRendererOlBeginTight\n",contents,
        "\n\\markdownRendererOlEndTight "}
    else
      return {"\\markdownRendererOlBegin\n",contents,
        "\n\\markdownRendererOlEnd "}
    end
  end
%    \end{macrocode}
% The formatter for a definition list. \t`items` is an array of tables, each of
% the form \t`{ term = t, definitions = defs, tight = tight }`, where \t`t` is a
% string and \t`defs` is an array of strings.  If \t`tight` is true, the list
% should have minimal spacing between items.
%  \begin{macrocode}
  local function dlitem(term,defs)
      return {"\\markdownRendererDlItem{",term,"}\n",defs}
  end

  function self.definitionlist(items,tight)
    local buffer = {}
    for _,item in ipairs(items) do
      buffer[#buffer + 1] = dlitem(item.term,
        util.intersperse(item.definitions, self.interblocksep))
    end
    local contents = util.intersperse(buffer, self.containersep)
    if tight then
      return {"\\markdownRendererDlBeginTight\n",contents,
        "\n\\markdownRendererDlEndTight "}
    else
      return {"\\markdownRendererDlBegin\n",contents,
        "\n\\markdownRendererDlEnd "}
    end
  end
%    \end{macrocode}
% The emphasized text formatter.
%  \begin{macrocode}
  function self.emphasis(s)
    return {"\\markdownRendererEmphasis{",s,"}"}
  end
%    \end{macrocode}
% The strongly emphasized text formatter.
%  \begin{macrocode}
  function self.strong(s)
    return {"\\markdownRendererStrongEmphasis{",s,"}"}
  end
%    \end{macrocode}
% The block quotation formatter.
%  \begin{macrocode}
  function self.blockquote(s)
    return {"\\markdownRendererBlockQuoteBegin\n",s,
      "\n\\markdownRendererBlockQuoteEnd "}
  end
%    \end{macrocode}
% The block verbatim code formatter.
%  \begin{macrocode}
  function self.verbatim(s)
    if options.verbatim then
      local name = util.cache(options.cacheDir, s, nil, nil, ".verbatim")
      return {"\\markdownRendererInputVerbatim{",name,"}"}
    else
      return {"\\markdownRendererCodeBlockBegin\n",escape(s),
        "\\markdownRendererCodeBlockEnd "}
    end
  end
%    \end{macrocode}
% The formatter of a header \t`s` at level \t`level`.
%  \begin{macrocode}
  function self.header(s,level)
    local cmd
    if level == 1 then
      cmd = "\\markdownRendererHeadingOne"
    elseif level == 2 then
      cmd = "\\markdownRendererHeadingTwo"
    elseif level == 3 then
      cmd = "\\markdownRendererHeadingThree"
    elseif level == 4 then
      cmd = "\\markdownRendererHeadingFour"
    elseif level == 5 then
      cmd = "\\markdownRendererHeadingFive"
    elseif level == 6 then
      cmd = "\\markdownRendererHeadingSix"
    else
      cmd = ""
    end
    return {cmd,"{",s,"}"}
  end
%    \end{macrocode}
% The footnote formatter.
%  \begin{macrocode}
  function self.note(contents)
    return {"\\markdownRendererFootnote{",contents,"}"}
  end

  return self
end
%    \end{macrocode}
% 
% \subsubsection{Markdown Reader}\label{sec:markdownreader}
% \blindtext
% 
% Normalizes a markdown reference tag. (Turns it lowercase, and collapses any
% adjacent whitespace characters.)
%  \begin{macrocode}
local function normalize_tag(tag)
  return unicode.utf8.lower(gsub(util.rope_to_string(tag), "[ \n\r\t]+", " "))
end
%    \end{macrocode}
% Creates a new markdown parser, where \t`writer` is a writer and where
% \t`options` is a table with options. The return value is a converter function
% that converts a markdown string using \t`writer`, returning the parsed
% document.  The converter assumes that the input has unix line endings
% (newline).
%  \begin{macrocode}
M.reader = {}
function M.reader.new(writer, options)
  local self = {}
  options = options or {}
%    \end{macrocode}
% Inherit options from the \t`defaultOptions` table.
%  \begin{macrocode}
  setmetatable(options, { __index = function (_, key)
    return defaultOptions[key] end })
%    \end{macrocode}
% This function expands into spaces, unless it is prohibited by the options
% (see section \ref{sec:luaoptions}).
%  \begin{macrocode}
  local expandtabs
  if options.preserveTabs then
    expandtabs = function(s) return s end
  else
    expandtabs = function(s)
                   if s:find("\t") then
                     return s:gsub("[^\n]*", util.expand_tabs_in_line)
                   else
                     return s
                   end
                 end
  end
%    \end{macrocode}
% These are the top level parsing functions.
%  \begin{macrocode}
  local syntax
  local blocks
  local inlines

  local parse_blocks =
    function(str)
      local res = lpeg.match(blocks, str)
      if res == nil
        then error(format("parse_blocks failed on:\n%s", str:sub(1,20)))
        else return res
        end
    end

  local parse_inlines =
    function(str)
      local res = lpeg.match(inlines, str)
      if res == nil
        then error(format("parse_inlines failed on:\n%s", str:sub(1,20)))
        else return res
        end
    end

  local parse_inlines_no_link =
    function(str)
      local res = lpeg.match(inlines_no_link, str)
      if res == nil
        then error(format("parse_inlines_no_link failed on:\n%s", str:sub(1,20)))
        else return res
        end
    end
%    \end{macrocode}
% \paragraph{Generic Parsers}
%  \begin{macrocode}
  local percent                = P("%")
  local asterisk               = P("*")
  local dash                   = P("-")
  local plus                   = P("+")
  local underscore             = P("_")
  local period                 = P(".")
  local hash                   = P("#")
  local ampersand              = P("&")
  local backtick               = P("`")
  local less                   = P("<")
  local more                   = P(">")
  local space                  = P(" ")
  local squote                 = P("'")
  local dquote                 = P('"')
  local lparent                = P("(")
  local rparent                = P(")")
  local lbracket               = P("[")
  local rbracket               = P("]")
  local circumflex             = P("^")
  local slash                  = P("/")
  local equal                  = P("=")
  local colon                  = P(":")
  local semicolon              = P(";")
  local exclamation            = P("!")

  local digit                  = R("09")
  local hexdigit               = R("09","af","AF")
  local letter                 = R("AZ","az")
  local alphanumeric           = R("AZ","az","09")
  local keyword                = letter * alphanumeric^0

  local doubleasterisks        = P("**")
  local doubleunderscores      = P("__")
  local fourspaces             = P("    ")

  local any                    = P(1)
  local fail                   = any - 1
  local always                 = P("")

  local escapable              = S("\\`*_{}[]()+_.!#-~:^")
  local anyescaped             = P("\\") / "" * escapable
                               + any

  local tab                    = P("\t")
  local spacechar              = S("\t ")
  local spacing                = S(" \n\r\t")
  local newline                = P("\n")
  local nonspacechar           = any - spacing
  local tightblocksep          = P("\001")

  local specialchar
  if options.smartEllipses then
    specialchar                = S("*_`&[]!\\.")
  else
    specialchar                = S("*_`&[]!\\")
  end

  local normalchar             = any -
                                 (specialchar + spacing + tightblocksep)
  local optionalspace          = spacechar^0
  local spaces                 = spacechar^1
  local eof                    = - any
  local nonindentspace         = space^-3 * - spacechar
  local indent                 = space^-3 * tab
                               + fourspaces / ""
  local linechar               = P(1 - newline)

  local blankline              = optionalspace * newline / "\n"
  local blanklines             = blankline^0
  local skipblanklines         = (optionalspace * newline)^0
  local indentedline           = indent    /"" * C(linechar^1 * newline^-1)
  local optionallyindentedline = indent^-1 /"" * C(linechar^1 * newline^-1)
  local sp                     = spacing^0
  local spnl                   = optionalspace * (newline * optionalspace)^-1
  local line                   = linechar^0 * newline
                               + linechar^1 * eof
  local nonemptyline           = line - blankline

  local chunk = line * (optionallyindentedline - blankline)^0

  -- block followed by 0 or more optionally
  -- indented blocks with first line indented.
  local function indented_blocks(bl)
    return Cs( bl
             * (blankline^1 * indent * -blankline * bl)^0
             * blankline^1 )
  end
%    \end{macrocode}
% \paragraph{List Parsers}
%  \begin{macrocode}
  local bulletchar = C(plus + asterisk + dash)

  local bullet     = ( bulletchar * #spacing * (tab + space^-3)
                     + space * bulletchar * #spacing * (tab + space^-2)
                     + space * space * bulletchar * #spacing * (tab + space^-1)
                     + space * space * space * bulletchar * #spacing
                     ) * -bulletchar

  if options.hashEnumerators then
    dig = digit + hash
  else
    dig = digit
  end

  local enumerator = C(dig^3 * period) * #spacing
                   + C(dig^2 * period) * #spacing * (tab + space^1)
                   + C(dig * period) * #spacing * (tab + space^-2)
                   + space * C(dig^2 * period) * #spacing
                   + space * C(dig * period) * #spacing * (tab + space^-1)
                   + space * space * C(dig^1 * period) * #spacing
%    \end{macrocode}
% \paragraph{Code Span Parsers}
%  \begin{macrocode}
  local openticks   = Cg(backtick^1, "ticks")

  local function captures_equal_length(s,i,a,b)
    return #a == #b and i
  end

  local closeticks  = space^-1 *
                      Cmt(C(backtick^1) * Cb("ticks"), captures_equal_length)

  local intickschar = (any - S(" \n\r`"))
                    + (newline * -blankline)
                    + (space - closeticks)
                    + (backtick^1 - closeticks)

  local inticks     = openticks * space^-1 * C(intickschar^1) * closeticks
%    \end{macrocode}
% \paragraph{Tag and Link Parsers}
%  \begin{macrocode}
  local leader        = space^-3

  -- in balanced brackets, parentheses, quotes:
  local bracketed     = P{ lbracket
                         * ((anyescaped - (lbracket + rbracket
                             + blankline^2)) + V(1))^0
                         * rbracket }

  local inparens      = P{ lparent
                         * ((anyescaped - (lparent + rparent
                             + blankline^2)) + V(1))^0
                         * rparent }

  local squoted       = P{ squote * alphanumeric
                         * ((anyescaped - (squote + blankline^2))
                             + V(1))^0
                         * squote }

  local dquoted       = P{ dquote * alphanumeric
                         * ((anyescaped - (dquote + blankline^2))
                             + V(1))^0
                         * dquote }

  -- bracketed 'tag' for markdown links, allowing nested brackets:
  local tag           = lbracket
                      * Cs((alphanumeric^1
                           + bracketed
                           + inticks
                           + (anyescaped - (rbracket + blankline^2)))^0)
                      * rbracket

  -- url for markdown links, allowing balanced parentheses:
  local url           = less * Cs((anyescaped-more)^0) * more
                      + Cs((inparens + (anyescaped-spacing-rparent))^1)

  -- quoted text possibly with nested quotes:
  local title_s       = squote  * Cs(((anyescaped-squote) + squoted)^0) * squote

  local title_d       = dquote  * Cs(((anyescaped-dquote) + dquoted)^0) * dquote

  local title_p       = lparent
                      * Cs((inparens + (anyescaped-rparent))^0)
                      * rparent

  local title         = title_d + title_s + title_p

  local optionaltitle = spnl * title * spacechar^0
                      + Cc("")
%    \end{macrocode}
% \paragraph{Footnotes}
%  \begin{macrocode}
  local rawnotes = {}

  local function strip_first_char(s)
    return s:sub(2)
  end

  -- like indirect_link
  local function lookup_note(ref)
    return function()
      local found = rawnotes[normalize_tag(ref)]
      if found then
        return writer.note(parse_blocks(found))
      else
        return {"[^", ref, "]"}
      end
    end
  end

  local function register_note(ref,rawnote)
    rawnotes[normalize_tag(ref)] = rawnote
    return ""
  end

  local RawNoteRef = #(lbracket * circumflex) * tag / strip_first_char

  local NoteRef    = RawNoteRef / lookup_note

  local NoteBlock

  if options.notes then
    NoteBlock = leader * RawNoteRef * colon * spnl * indented_blocks(chunk)
              / register_note
  else
    NoteBlock = fail
  end
%    \end{macrocode}
% \paragraph{Links and References Helpers}
%  \begin{macrocode}
  -- List of references defined in the document
  local references

  -- add a reference to the list
  local function register_link(tag,url,title)
      references[normalize_tag(tag)] = { url = url, title = title }
      return ""
  end

  -- parse a reference definition:  [foo]: /bar "title"
  local define_reference_parser =
    leader * tag * colon * spacechar^0 * url * optionaltitle * blankline^1

  -- lookup link reference and return either
  -- the link or nil and fallback text.
  local function lookup_reference(label,sps,tag)
      local tagpart
      if not tag then
          tag = label
          tagpart = ""
      elseif tag == "" then
          tag = label
          tagpart = "[]"
      else
          tagpart = {"[", parse_inlines(tag), "]"}
      end
      if sps then
        tagpart = {sps, tagpart}
      end
      local r = references[normalize_tag(tag)]
      if r then
        return r
      else
        return nil, {"[", parse_inlines(label), "]", tagpart}
      end
  end

  -- lookup link reference and return a link, if the reference is found,
  -- or a bracketed label otherwise.
  local function indirect_link(label,sps,tag)
    return function()
      local r,fallback = lookup_reference(label,sps,tag)
      if r then
        return writer.link(parse_inlines_no_link(label), r.url, r.title)
      else
        return fallback
      end
    end
  end

  -- lookup image reference and return an image, if the reference is found,
  -- or a bracketed label otherwise.
  local function indirect_image(label,sps,tag)
    return function()
      local r,fallback = lookup_reference(label,sps,tag)
      if r then
        return writer.image(writer.string(label), r.url, r.title)
      else
        return {"!", fallback}
      end
    end
  end
%    \end{macrocode}
% \paragraph{Inline Elements}
%  \begin{macrocode}
  local Inline    = V("Inline")

  local Str       = normalchar^1 / writer.string

  local Ellipsis  = P("...") / writer.ellipsis

  local Smart     = Ellipsis

  local Symbol    = (specialchar - tightblocksep) / writer.string

  local Code      = inticks / writer.code

  local bqstart      = more
  local headerstart  = hash
                     + (line * (equal^1 + dash^1) * optionalspace * newline)

  if options.blankBeforeBlockquote then
    bqstart = fail
  end

  if options.blankBeforeHeading then
    headerstart = fail
  end

  local Endline   = newline * -( -- newline, but not before...
                        blankline -- paragraph break
                      + tightblocksep  -- nested list
                      + eof       -- end of document
                      + bqstart
                      + headerstart
                    ) * spacechar^0 / writer.space

  local Space     = spacechar^2 * Endline / writer.linebreak
                  + spacechar^1 * Endline^-1 * eof / ""
                  + spacechar^1 * Endline^-1 * optionalspace / writer.space

  -- parse many p between starter and ender
  local function between(p, starter, ender)
      local ender2 = B(nonspacechar) * ender
      return (starter * #nonspacechar * Ct(p * (p - ender2)^0) * ender2)
  end

  local Strong = ( between(Inline, doubleasterisks, doubleasterisks)
                 + between(Inline, doubleunderscores, doubleunderscores)
                 ) / writer.strong

  local Emph   = ( between(Inline, asterisk, asterisk)
                 + between(Inline, underscore, underscore)
                 ) / writer.emphasis

  local urlchar = anyescaped - newline - more

  local AutoLinkUrl   = less
                      * C(alphanumeric^1 * P("://") * urlchar^1)
                      * more
                      / function(url) return writer.link(writer.string(url),url) end

  local AutoLinkEmail = less
                      * C((alphanumeric + S("-._+"))^1 * P("@") * urlchar^1)
                      * more
                      / function(email)
                        return writer.link(writer.string(email),"mailto:"..email) end

  local DirectLink    = (tag / parse_inlines_no_link)  -- no links inside links
                      * spnl
                      * lparent
                      * (url + Cc(""))  -- link can be empty [foo]()
                      * optionaltitle
                      * rparent
                      / writer.link

  local IndirectLink = tag * (C(spnl) * tag)^-1 / indirect_link

  -- parse a link or image (direct or indirect)
  local Link          = DirectLink + IndirectLink

  local DirectImage   = exclamation
                      * (tag / parse_inlines)
                      * spnl
                      * lparent
                      * (url + Cc(""))  -- link can be empty [foo]()
                      * optionaltitle
                      * rparent
                      / writer.image

  local IndirectImage  = exclamation * tag * (C(spnl) * tag)^-1 / indirect_image

  local Image         = DirectImage + IndirectImage

  -- avoid parsing long strings of * or _ as emph/strong
  local UlOrStarLine  = asterisk^4 + underscore^4 / writer.string

  local EscapedChar   = S("\\") * C(escapable) / writer.string
%    \end{macrocode}
% \paragraph{Block Elements}
%  \begin{macrocode}
  local Block          = V("Block")

  local Verbatim       = Cs( (blanklines
                           * ((indentedline - blankline))^1)^1
                           ) / expandtabs / writer.verbatim

  -- strip off leading > and indents, and run through blocks
  local Blockquote     = Cs((
            ((leader * more * space^-1)/"" * linechar^0 * newline)^1
          * (-blankline * linechar^1 * newline)^0
          * blankline^0
          )^1) / parse_blocks / writer.blockquote

  local function lineof(c)
      return (leader * (P(c) * optionalspace)^3 * newline * blankline^1)
  end

  local HorizontalRule = ( lineof(asterisk)
                         + lineof(dash)
                         + lineof(underscore)
                         ) / writer.hrule

  local Reference      = define_reference_parser / register_link

  local Paragraph      = nonindentspace * Ct(Inline^1) * newline
                       * ( blankline^1
                         + #hash
                         + #(leader * more * space^-1)
                         )
                       / writer.paragraph

  local Plain          = nonindentspace * Ct(Inline^1) / writer.plain
%    \end{macrocode}
% \paragraph{Lists}
%  \begin{macrocode}
  local starter = bullet + enumerator

  -- we use \001 as a separator between a tight list item and a
  -- nested list under it.
  local NestedList            = Cs((optionallyindentedline - starter)^1)
                              / function(a) return "\001"..a end

  local ListBlockLine         = optionallyindentedline
                                - blankline - (indent^-1 * starter)

  local ListBlock             = line * ListBlockLine^0

  local ListContinuationBlock = blanklines * (indent / "") * ListBlock

  local function TightListItem(starter)
      return -HorizontalRule
             * (Cs(starter / "" * ListBlock * NestedList^-1) / parse_blocks)
             * -(blanklines * indent)
  end

  local function LooseListItem(starter)
      return -HorizontalRule
             * Cs( starter / "" * ListBlock * Cc("\n")
               * (NestedList + ListContinuationBlock^0)
               * (blanklines / "\n\n")
               ) / parse_blocks
  end

  local BulletList = ( Ct(TightListItem(bullet)^1)
                       * Cc(true) * skipblanklines * -bullet
                     + Ct(LooseListItem(bullet)^1)
                       * Cc(false) * skipblanklines ) / writer.bulletlist

  local function orderedlist(items,tight,startNumber)
    if options.startNumber then
      startNumber = tonumber(startNumber) or 1  -- fallback for '#'
    else
      startNumber = nil
    end
    return writer.orderedlist(items,tight,startNumber)
  end

  local OrderedList = Cg(enumerator, "listtype") *
                      ( Ct(TightListItem(Cb("listtype")) * TightListItem(enumerator)^0)
                        * Cc(true) * skipblanklines * -enumerator
                      + Ct(LooseListItem(Cb("listtype")) * LooseListItem(enumerator)^0)
                        * Cc(false) * skipblanklines
                      ) * Cb("listtype") / orderedlist

  local defstartchar = S("~:")
  local defstart     = ( defstartchar * #spacing * (tab + space^-3)
                     + space * defstartchar * #spacing * (tab + space^-2)
                     + space * space * defstartchar * #spacing * (tab + space^-1)
                     + space * space * space * defstartchar * #spacing
                     )

  local dlchunk = Cs(line * (indentedline - blankline)^0)

  local function definition_list_item(term, defs, tight)
    return { term = parse_inlines(term), definitions = defs }
  end

  local DefinitionListItemLoose = C(line) * skipblanklines
                           * Ct((defstart * indented_blocks(dlchunk) / parse_blocks)^1)
                           * Cc(false)
                           / definition_list_item

  local DefinitionListItemTight = C(line)
                           * Ct((defstart * dlchunk / parse_blocks)^1)
                           * Cc(true)
                           / definition_list_item

  local DefinitionList =  ( Ct(DefinitionListItemLoose^1) * Cc(false)
                          +  Ct(DefinitionListItemTight^1)
                             * (skipblanklines * -DefinitionListItemLoose * Cc(true))
                          ) / writer.definitionlist
%    \end{macrocode}
% \paragraph{Blanks}
%  \begin{macrocode}
  local Blank          = blankline / ""
                       + NoteBlock
                       + Reference
                       + (tightblocksep / "\n")
%    \end{macrocode}
% \paragraph{Headings}
%  \begin{macrocode}
  -- parse Atx heading start and return level
  local HeadingStart = #hash * C(hash^-6) * -hash / length

  -- parse setext header ending and return level
  local HeadingLevel = equal^1 * Cc(1) + dash^1 * Cc(2)

  local function strip_atx_end(s)
    return s:gsub("[#%s]*\n$","")
  end

  -- parse atx header
  local AtxHeading = Cg(HeadingStart,"level")
                     * optionalspace
                     * (C(line) / strip_atx_end / parse_inlines)
                     * Cb("level")
                     / writer.header

  -- parse setext header
  local SetextHeading = #(line * S("=-"))
                     * Ct(line / parse_inlines)
                     * HeadingLevel
                     * optionalspace * newline
                     / writer.header
%    \end{macrocode}
% \paragraph{Syntax Specification}
%  \begin{macrocode}
  syntax =
    { "Blocks",

      Blocks                = Blank^0 *
                              Block^-1 *
                              (Blank^0 / function()
                                return writer.interblocksep end * Block)^0 *
                              Blank^0 *
                              eof,

      Blank                 = Blank,

      Block                 = V("Blockquote")
                            + V("Verbatim")
                            + V("HorizontalRule")
                            + V("BulletList")
                            + V("OrderedList")
                            + V("Heading")
                            + V("DefinitionList")
                            + V("Paragraph")
                            + V("Plain"),

      Blockquote            = Blockquote,
      Verbatim              = Verbatim,
      HorizontalRule        = HorizontalRule,
      BulletList            = BulletList,
      OrderedList           = OrderedList,
      Heading               = AtxHeading + SetextHeading,
      DefinitionList        = DefinitionList,
      DisplayHtml           = DisplayHtml,
      Paragraph             = Paragraph,
      Plain                 = Plain,

      Inline                = V("Str")
                            + V("Space")
                            + V("Endline")
                            + V("UlOrStarLine")
                            + V("Strong")
                            + V("Emph")
                            + V("NoteRef")
                            + V("Link")
                            + V("Image")
                            + V("Code")
                            + V("AutoLinkUrl")
                            + V("AutoLinkEmail")
                            + V("EscapedChar")
                            + V("Smart")
                            + V("Symbol"),

      Str                   = Str,
      Space                 = Space,
      Endline               = Endline,
      UlOrStarLine          = UlOrStarLine,
      Strong                = Strong,
      Emph                  = Emph,
      NoteRef               = NoteRef,
      Link                  = Link,
      Image                 = Image,
      Code                  = Code,
      AutoLinkUrl           = AutoLinkUrl,
      AutoLinkEmail         = AutoLinkEmail,
      InlineHtml            = InlineHtml,
      HtmlEntity            = HtmlEntity,
      EscapedChar           = EscapedChar,
      Smart                 = Smart,
      Symbol                = Symbol,
    }

  if not options.definitionLists then
    syntax.DefinitionList = fail
  end

  if not options.notes then
    syntax.NoteRef = fail
  end

  if not options.smartEllipses then
    syntax.Smart = fail
  end

  blocks = Ct(syntax)

  local inlines_t = util.table_copy(syntax)
  inlines_t[1] = "Inlines"
  inlines_t.Inlines = Inline^0 * (spacing^0 * eof / "")
  inlines = Ct(inlines_t)

  inlines_no_link_t = util.table_copy(inlines_t)
  inlines_no_link_t.Link = fail
  inlines_no_link = Ct(inlines_no_link_t)
%    \end{macrocode}
% \paragraph{Exported Conversion Function}
%  \begin{macrocode}
  function self.convert(input)
    references = {} -- TODO: Add caching and a reference persistence option.
    local opt_string = {}
    for k,_ in pairs(defaultOptions) do -- Create salt out of boolean options.
      local v = options[k]
      if type(v) == "boolean" then
        opt_string[#opt_string+1] = k .. "=" .. tostring(v)
      end
    end
    table.sort(opt_string)
    local name = util.cache(options.cacheDir, input,
      table.concat(opt_string, ","), function(input)
        return util.rope_to_string(parse_blocks(input))
      end, ".md" .. writer.suffix)
    return string.format([[\input "%s"\relax]], name)
  end
  return self
end

%    \end{macrocode}
% \subsubsection{Conversion from Markdown to \TeX{}}
% \blindtext
%  \begin{macrocode}
function M.converter.new(options)
  local writer = M.writer.new(options)
  local reader = M.reader.new(writer, options)
  return reader.convert
end

return M
%    \end{macrocode}
% \blindtext
%
% \iffalse
%</lua>
%<*tex>
% \fi\subsection{Plain \TeX{} Implementation}\label{sec:teximplementation}
% The plain \TeX{} implementation provides macros for the interfacing between
% \TeX{} and Lua and for the buffering of input text. These macros are then
% used to implement the macros for the conversion from markdown to \TeX{}
% exposed by the plain \TeX{} interface (see Section \ref{sec:texinterface}).
%
% \subsubsection{Logging Facilities}
% The \mdef{markdownInfo}, \mdef{markdownWarning}, and
% \mdef{markdownError} macros provide access to logging to the rest of
% the macros.
%  \begin{macrocode}
\def\markdownInfo#1{%
  \message{(l.\the\inputlineno) markdown.tex info: #1.}}%
\def\markdownWarning#1{%
  \message{(l.\the\inputlineno) markdown.tex warning: #1}}%
\def\markdownError#1{%
  \errmessage{(l.\the\inputlineno) markdown.tex error: #1}}%
%    \end{macrocode}
%
% \subsubsection{Lua Snippets}
% The \mdef{markdownLuaOptions} macro expands to a Lua table that
% contains the plain \TeX{} options (see Section \ref{sec:texoptions}) in a
% format recognized by Lua (see Section \ref{sec:luaoptions}). Note that the
% boolean options are not sanitized and expect the plain \TeX{} option macros
% to expand to either \t`true` or \t`false`.
%  \begin{macrocode}
\def\markdownLuaOptions{{%
  \ifx\markdownOptionBlankBeforeBlockquote\undefined\else
    blankBeforeBlockquote = \markdownOptionBlankBeforeBlockquote,
  \fi
  \ifx\markdownOptionBlankBeforeHeading\undefined\else
    blankBeforeHeading = \markdownOptionBlankBeforeHeading,
  \fi
  \ifx\markdownOptionCacheDir\undefined\else
    cacheDir = "\markdownOptionCacheDir",
  \fi
  \ifx\markdownOptionDefinitionLists\undefined\else
    definitionLists = \markdownOptionDefinitionLists,
  \fi
  \ifx\markdownOptionHashEnumerator\undefined\else
    hashEnumerator = \markdownOptionHashEnumerator,
  \fi
  \ifx\markdownOptionHybrid\undefined\else
    hybrid = \markdownOptionHybrid,
  \fi
  \ifx\markdownOptionNotes\undefined\else
    notes = \markdownOptionNotes,
  \fi
  \ifx\markdownPreserveTabs\undefined\else
    preserveTabs = \markdownPreserveTabs,
  \fi
  \ifx\markdownSmartEllipses\undefined\else
    smartEllipses = \markdownSmartEllipses,
  \fi
  \ifx\markdownStartNumber\undefined\else
    startNumber = \markdownStartNumber,
  \fi
  \ifx\markdownVerbatim\undefined\else
    verbatim = \markdownVerbatim,
  \fi}
}%
%    \end{macrocode}
%
% The \mdef{markdownPrepare} macro contains the Lua code that is executed prior
% to any conversion from markdown to \TeX{}. It exposes the \luam{convert}
% function for the use by any further Lua code.
%  \begin{macrocode}
\def\markdownPrepare{%
%    \end{macrocode}
% First, ensure that the \m{markdownOptionCacheDir} directory exists.
%  \begin{macrocode}
  local lfs = require("lfs")
  local cacheDir = "\markdownOptionCacheDir"
  if lfs.isdir(cacheDir) == true then else
    assert(lfs.mkdir(cacheDir))
  end
%    \end{macrocode}
% Next, load the \t`markdown` module and create a \t`converter` function using
% the plain \TeX{} options, which were serialized to a Lua table via the
% \m{markdownLuaOptions} macro.
%  \begin{macrocode}
  local md = require("markdown")
  local convert = md.converter.new(\markdownLuaOptions)
}%
%    \end{macrocode}
%
% \subsubsection{Lua \t`\textbackslash write18` Bridge}\label{sec:luabridge}
% The following \TeX{} code is intended for \TeX{} engines that do not provide
% direct access to Lua, but expose the shell of the operating system through
% the output file stream 18 (\Hologo{XeTeX}, \hologo{pdfLaTeX}).
% The \m{markdownLuaExecute} and \m{markdownReadAndConvert} defined here and in
% Section \ref{sec:directlua} are meant to be transparent to the remaining
% code.
%
% The package assumes that although the user is not using the Lua\TeX{} engine,
% their TeX distribution contains it, and uses shell access to produce and
% execute Lua scripts using the \TeX{}Lua interpreter (see
% \cite[Section~3.1.1]{luatex16}).
%  \begin{macrocode}
\ifx\directlua\undefined
%    \end{macrocode}
%
% The \mdef{markdownLuaExecuteShellEscape} count register contains the numeric
% value of either the \m{pdfshellescape} (Lua\TeX{}, \Hologo{pdfTeX}) or the
% \m{shellescape} (\Hologo{XeTeX}) commands. This value indicates, whether the
% shell access is enabled (\t`1`), disabled (\t`0`), or restricted (\t`2`). 
% If neither of these commands is defined, announce that the \TeX{} engine
% is unsupported.
%  \begin{macrocode}
  \csname newcount\endcsname\markdownLuaExecuteShellEscape
  \ifx\pdfshellescape\undefined
    \ifx\shellescape\undefined
      \markdownError{You are using a TeX engine that supports neither
        Lua nor shell access via the file stream 18. At the moment, the
        Markdown package does not work with your engine}%
    \else
      \markdownLuaExecuteShellEscape=\shellescape
    \fi
  \else
    \markdownLuaExecuteShellEscape=\pdfshellescape
  \fi
%    \end{macrocode}
%
% The \mdef{markdownLuaExecute} macro executes the Lua code it has received as
% its first argument. The Lua code may not directly interact with the \TeX{}
% engine, but it can use the \luam{print} function in the same manner it
% would use the \luam{tex.print} method.
%  \begin{macrocode}
  \def\markdownLuaExecute#1{%
%    \end{macrocode}
% If the shell is accessible, create the file
% \m{markdownOptionHelperScriptFileName} and fill it with the input Lua code
% prepended with \pkg{kpathsea} initialization, so that Lua modules from the
% \TeX{} distribution are available.
%  \begin{macrocode}
    \ifnum\markdownLuaExecuteShellEscape=1%
      \immediate\openout\markdownOptionFileStream=%
        \markdownOptionHelperScriptFileName
      \markdownInfo{Writing a helper Lua script to the file
        "\markdownOptionHelperScriptFileName"}%
      \immediate\write\markdownOptionFileStream{%
        local kpse = require('kpse')
        kpse.set_program_name('luatex') #1}%
      \immediate\closeout\markdownOptionFileStream
%    \end{macrocode}
% Execute the generated \m{markdownOptionHelperScriptFileName} Lua script using
% the \TeX{}Lua binary and store the output in the
% \m{markdownOptionOutputTempFileName} file.
%  \begin{macrocode}
      \markdownInfo{Executing a helper Lua script from the file
        "\markdownOptionHelperScriptFileName" and storing the result in the
        file "\markdownOptionOutputTempFileName"}%
      \immediate\write18{texlua "\markdownOptionHelperScriptFileName" >
        "\markdownOptionOutputTempFileName"}%
%    \end{macrocode}
% \m{input} the generated \m{markdownOptionOutputTempFileName} file.
%  \begin{macrocode}
      \input\markdownOptionOutputTempFileName\relax
    \else
%    \end{macrocode}
% If the shell is inaccessible, let the user know and suggest a remedy.
%  \begin{macrocode}
      \markdownError{I can not access the shell. Run the TeX
        compiler with the --shell-escape or the --enable-write18 flag}%
    \fi}%
%    \end{macrocode}
%
% The \mdef{markdownReadAndConvert} macro stores any subsequent lines of input
% in the file \m{markdownOptionInputTempFileName} before it encounters a control
% sequence specified by its single argument. After that, the macro coverts the
% contents of the file \m{markdownOptionInputTempFileName} from markdown to
% \TeX{} and \t`input`s it.
%
% This macro is largely a rewrite of the \Hologo{LaTeX2e} \m{filecontents} macro
% to plain \TeX{}.
%  \begin{macrocode}
  \begingroup
%    \end{macrocode}
% Make the newline character active and swap the character codes of the
% backslash symbol (\t`\textbackslash`) and the pipe symbol (\t`|`), so that
% we can use the backslash as an ordinary character inside the macro definition.
%  \begin{macrocode}
    \catcode`\^^M=13%
    \catcode`|=0%
    \catcode`\\=12%
    |gdef|markdownReadAndConvert#1{%
      |begingroup%
%    \end{macrocode}
% Open the \m{markdownOptionInputTempFileName} file for writing.
%  \begin{macrocode}
      |immediate|openout|markdownOptionFileStream%
        |markdownOptionInputTempFileName%
      |markdownInfo{Buffering markdown input into the temporary %
        input file "|markdownOptionInputTempFileName" and scanning %
        for the closing \#1 command}%
%    \end{macrocode}
% Locally change the category of the special characters to \emph{other} in
% order to prevent unwanted interpretation of the input.
%  \begin{macrocode}
      |catcode`| =12|catcode`|\=12|catcode`|{=12%
      |catcode`|}=12|catcode`|$=12|catcode`|&=12%
      |catcode`|#=12|catcode`|^=12|catcode`|_=12%
      |catcode`|%=12|catcode`|~=12%
%    \end{macrocode}
% The \m{markdownReadAndConvertProcessLine} macro will process the individual
% lines of output. Note the use of the comments to ensure that the entire macro
% is at a single line and therefore no (active) newline symbols are produced.
%  \begin{macrocode}
      |def|markdownReadAndConvertProcessLine##1\#1##2\#1##3|relax{%
%    \end{macrocode}
% When the ending control sequence does not appear in the line, store it in the
% \m{markdownOptionInputTempFileName} file.
%  \begin{macrocode}
        |ifx|relax##3|relax%
          |immediate|write|markdownOptionFileStream{##1}%
        |else%
%    \end{macrocode}
% When the ending control sequence appears in the line, make the next newline
% character close the \m{markdownOptionInputTempFileName} file, return the
% character categories back to the former state, convert the
% \m{markdownOptionInputTempFileName} file from markdown to \TeX{} and \m{input}
% the result of the conversion.
%  \begin{macrocode}
          |def^^M{%
            |immediate|closeout|markdownOptionFileStream%
            |endgroup%
            |markdownInput|markdownOptionInputTempFileName}%
%    \end{macrocode}
% When the ending control sequence does not appear at the beginning of the line,
% append the preceding string to the \m{markdownOptionInputTempFileName} file.
%  \begin{macrocode}
          |ifx|relax##1|relax|else%
            |immediate|write|markdownOptionFileStream{##1}%
          |fi%
        |fi%
%    \end{macrocode}
% Repeat with the next line.
%  \begin{macrocode}
        ^^M}%
%    \end{macrocode}
% Make the newline character active at expansion time and make it consume the
% rest of the line on expansion. Throw away the rest of the first line and
% pass the second line to the \m{markdownReadAndConvertProcessLine} macro.
%  \begin{macrocode}
      |catcode`|^^M=13%
      |def^^M##1^^M{%
        |def^^M####1^^M{%
          |markdownReadAndConvertProcessLine####1\#1\#1|relax}%
        ^^M}%
      ^^M}%
%    \end{macrocode}
% Reset the character categories back to the former state.
%  \begin{macrocode}
  |endgroup
%    \end{macrocode}
%
% \subsubsection{Direct Lua Access}\label{sec:directlua}
% The following \TeX{} code is intended for \TeX{} engines that provide
% direct access to Lua (Lua\TeX{}). The \m{markdownLuaExecute} and
% \m{markdownReadAndConvert} defined here and in Section \ref{sec:luabridge}
% are meant to be transparent to the remaining code.
%  \begin{macrocode}
\else
%    \end{macrocode}
% The direct Lua access version of the \m{markdownLuaExecute} macro is defined
% in terms of the \m{directlua} primitive. The \luam{print} function is set as
% an alias to the \m{tex.print} method in order to mimic the behaviour of the
% \m{markdownLuaExecute} definition from Section \ref{sec:luabridge},
%  \begin{macrocode}
  \def\markdownLuaExecute#1{\directlua{local print = tex.print #1}}%
%    \end{macrocode}
% In the definition of the direct Lua access version of the
% \m{markdownReadAndConvert} macro, we will be using the hash symbol (\t`\#`),
% the underscore symbol (\t`_`), the caret symbol (\t`\^`), the backslash
% symbol (\t`\textbackslash`), the percent sign (\t`\%`), and the braces
% (\t`\{\}`) as a part of the Lua syntax.
%  \begin{macrocode}
  \begingroup
%    \end{macrocode}
%
% To this end, we will make the underscore and caret symbols ordinary
% characters,
%  \begin{macrocode}
    \catcode`\_=12%
    \catcode`\^=12%
%    \end{macrocode}
% swap the category codes of the hash symbol and the slash symbol (\t`/`).
%  \begin{macrocode}
    \catcode`\/=6%
    \catcode`\#=12%
%    \end{macrocode}
% swap the category codes of the percent sign and the at symbol (\t`@`).
%  \begin{macrocode}
    \catcode`\@=14%
    \catcode`\%=12%
%    \end{macrocode}
% swap the category codes of the backslash symbol and the pipe symbol (\t`|`),
%  \begin{macrocode}
    \catcode`|=0@
    \catcode`\\=12@
%    \end{macrocode}
% Braces are a part of the plain \TeX{} syntax, but they are not removed during
% expansion, so we do not need to bother with changing their category codes.
%  \begin{macrocode}
    |gdef|markdownReadAndConvert/1{@
      |markdownInfo{Buffering markdown input and scanning for the
        closing \/1 command}@
      |directlua{@
%    \end{macrocode}
% Set up an empty Lua table that will serve as our buffer.
%  \begin{macrocode}
        |markdownPrepare
        local buffer = {}
%    \end{macrocode}
% Register a callback that will notify you about new lines of input.
%  \begin{macrocode}
        callback.register("process_input_buffer", function (line)
%    \end{macrocode}
% When the ending control sequence appears on a line, unregister the callback,
% convert the contents of our buffer from markdown to \TeX{}, and insert the
% result into the input line buffer of \TeX{}.
%  \begin{macrocode}
          if line:match[[^.-\/1]] then
            buffer[#buffer+1] = line:gsub([[\/1.*]], "")
            callback.register("process_input_buffer", nil)
            local input = table.concat(buffer, "\n")
            local output = convert(input)
            return [[\markdownInfo{The \/1 command was found}]] .. output
%    \end{macrocode}
% When the ending control sequence does not appear on a line, store the line in
% our buffer, and insert either \m{fi}, if this is the first line of input,
% or an empty token list to the input line buffer of \TeX{}.
%  \begin{macrocode}
          else
            buffer[#buffer+1] = line
            return #buffer == 1 and [[\]] .. "fi" or ""
          end
        end)}@
%    \end{macrocode}
% Insert \m{iffalse} after the \m{markdownReadAndConvert} macro in order to
% consume the rest of the first line of input.
%  \begin{macrocode}
      |iffalse}@
%    \end{macrocode}
% Reset the character categories back to the former state.
%  \begin{macrocode}
  |endgroup
\fi
%    \end{macrocode}
%
% \subsubsection{Conversion from Markdown to \TeX{}}
% The \m{markdownBegin} macro is a special instance of the
% \m{markdownReadAndConvert} macro that recognizes the 
% \m{markdownEnd} ending control sequence.
%  \begin{macrocode}
\def\markdownBegin{\markdownReadAndConvert{markdownEnd}}%
%    \end{macrocode}
%
% The \m{markdownInput} macro uses an implementation of the
% \m{markdownLuaExecute} macro to convert the contents of the file whose
% filename it has received as its single argument from markdown to \TeX{}.
%  \begin{macrocode}
\def\markdownInput#1{%
  \markdownInfo{Including markdown document "#1"}%
  \markdownLuaExecute{%
    \markdownPrepare
    local input = assert(io.open("#1","r")):read("*a")
    print(convert(input))}}%
%    \end{macrocode}
%
% \iffalse
%</tex>
% \fi
%
% \iffalse
%<*latex>
% \fi\subsection{\LaTeX{} Implementation}\label{sec:lateximplementation}
% \blindtext
%
% \iffalse
%</latex>
% \fi
%
% \iffalse
%<*context>
% \fi\subsection{\Hologo{ConTeXt} Implementation}
% \label{sec:contextimplementation}
% \blindtext
%
% \iffalse
%</context>
% \fi
