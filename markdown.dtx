% \iffalse
%<*driver>
\documentclass{ltxdoc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{blindtext}
\usepackage{hologo}

% Make paragraphs numbered.
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
            {-2.5ex\@plus -1ex \@minus -.25ex}%
            {1.25ex \@plus .25ex}%
            {\normalfont\normalsize\bfseries}}
\makeatother
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

% Define some user markup.
\let\pkg\textsf

\begin{document}
  \RecordChanges
  \MakeShortVerb{`}
  \DocInput{markdown.dtx}
  \PrintIndex
  \PrintChanges
\end{document}
%</driver>
% \fi
%
% \title{A Markdown interpreter for \TeX{}}
% \author{Vít Novotný}
% \date{\today}
% \maketitle
% \tableofcontents
%
% \section{Introduction}
% This document is a reference manual for the \pkg{Markdown} package.
% \blindtext
%
% \subsection{About \pkg{Markdown}}
% \blindtext
%
% \subsection{License}
% \blindtext
%
% \subsection{Feedback}
% \blindtext
%
% \subsection{Acknowledgements}
% \blindtext
%
% \subsection{Prerequisites}
% \blindtext
%
%  \begin{macrocode}
%<*lua>
local lpeg = require("lpeg")
local md5 = require("md5")
local unicode = require("unicode")
%</lua>
%    \end{macrocode}
%
% \section{User Guide}
% \blindtext
%
% \subsection{Lua Interface}
% \blindtext
%
% \subsubsection{The recognized options}
% \blindtext
%
% \begin{description}
%   \item[\blindtext] \blindtext
% \end{description}
%  \begin{macrocode}
%  `cacheDir`
%  :   The directory in which temporary files are stored.
% 
%  and that may contain the following fields:
% 
%  `hybrid`
%  :   Prevents the escaping of special TeX characters. This makes it possible
%      to intersperse the Markdown markup with TeX code.
% 
%  `verbatim`
%  :   Code blocks will not be surrounded by \markdownCodeBlockBegin and
%      \markdownCodeBlockEnd and have the special TeX characters escaped in
%      their contents. Instead, their contents will be stored in a temporary
%      file inside `cachedir`. The pathname of this file will be passed to the
%      \markdownInputVerbatim macro.
% 
%      `preserveTabs`
%      :   Preserve tabs instead of converting to spaces.
% 
%      `smartEllipses`
%      :   Parse ellipses intelligently.
% 
%      `startNumber`
%      :   Make the opening number in an ordered list significant.
% 
%      `notes`
%      :   Enable footnotes as in pandoc.
% 
%      `definitionLists`
%      :   Enable definition lists as in pandoc.
% 
%      `requireBlankBeforeBlockquote`
%      :   Require a blank line between a paragraph and a following
%          block quote.
% 
%      `requireBlankBeforeHeader`
%      :   Require a blank line between a paragraph and a following
%          header.
% 
%      `hashEnumerators`
%      :   Allow `#` instead of a digit for an ordered list enumerator
%          (equivalent to `1`).
%    \end{macrocode}
% 
% \section{Implementation}
% \iffalse
%<*lua>
% \fi\subsection{Lua interface}
% \blindtext
%
%  \begin{macrocode}
local upper, gsub, format, length =
  string.upper, string.gsub, string.format, string.len
local concat = table.concat
local P, R, S, V, C, Cg, Cb, Cmt, Cc, Ct, B, Cs, any =
  lpeg.P, lpeg.R, lpeg.S, lpeg.V, lpeg.C, lpeg.Cg, lpeg.Cb,
  lpeg.Cmt, lpeg.Cc, lpeg.Ct, lpeg.B, lpeg.Cs, lpeg.P(1)
local lpegmatch = lpeg.match
local utf8 = unicode.utf8
local M = {}
%    \end{macrocode}
% 
% \subsubsection{Utility functions}
% \blindtext
% 
% Prints an error message and exits.
%  \begin{macrocode}
local util = {}
function util.err(msg, exit_code)
  io.stderr:write("lunamark: " .. msg .. "\n")
  os.exit(exit_code or 1)
end
%    \end{macrocode}
% Creates a shallow copy of a table including metatables.
%  \begin{macrocode}
function util.table_copy(t)
  local u = { }
  for k, v in pairs(t) do u[k] = v end
  return setmetatable(u, getmetatable(t))
end
%    \end{macrocode}
% Expands tabs in a single line of text.
%  \begin{macrocode}
function util.expand_tabs_in_line(s, tabstop)
  local tab = tabstop or 4
  local corr = 0
  return (s:gsub("()\t", function(p)
            local sp = tab - (p - 1 + corr) % tab
            corr = corr - 1 + sp
            return string.rep(" ", sp)
          end))
end
%    \end{macrocode}
% Walks a rope `t`, applying a function `f` to each leaf element in order. A
% rope is an array whose elements may be ropes, strings, numbers, or functions.
% If a leaf element is a function, call it and get the return value before
% proceeding.
%  \begin{macrocode}
function util.walk(t, f)
    local typ = type(t)
    if typ == "string" then
      f(t)
    elseif typ == "table" then
      local i = 1
      local n
      n = t[i]
      while n do
        util.walk(n, f)
        i = i + 1
        n = t[i]
      end
    elseif typ == "function" then
      local ok, val = pcall(t)
      if ok then
        util.walk(val,f)
      end
    else
      f(tostring(t))
    end
end
%    \end{macrocode}
% Flattens an array.
%  \begin{macrocode}
function util.flatten(ary)
  local new = {}
  for i,v in ipairs(ary) do
    if type(v) == "table" then
      for j,w in ipairs(util.flatten(v)) do
        new[#new + 1] = w
      end
    else
      new[#new + 1] = v
    end
  end
  return new
end
%    \end{macrocode}
% Converts a rope to a string.
%  \begin{macrocode}
function util.rope_to_string(rope)
  local buffer = {}
  util.walk(rope, function(x) buffer[#buffer + 1] = x end)
  return table.concat(buffer)
end
%    \end{macrocode}
% Retrieves the last item in a rope.
%  \begin{macrocode}
function util.rope_last(rope)
  if #rope == 0 then
    return nil
  else
    local l = rope[#rope]
    if type(l) == "table" then
      return util.rope_last(l)
    else
      return l
    end
  end
end
%    \end{macrocode}
% Given an array `ary`, returns a new array with `x` interspersed between
% elements of `ary`.
%  \begin{macrocode}
function util.intersperse(ary, x)
  local new = {}
  local l = #ary
  for i,v in ipairs(ary) do
    local n = #new
    new[n + 1] = v
    if i ~= l then
      new[n + 2] = x
    end
  end
  return new
end
%    \end{macrocode}
% Given an array `ary`, returns a new array with each element `x` of `ary`
% replaced by `f(x)`.
%  \begin{macrocode}
function util.map(ary, f)
  local new = {}
  for i,v in ipairs(ary) do
    new[i] = f(v)
  end
  return new
end
%    \end{macrocode}
% Given a table `char_escapes` mapping escapable characters onto their escaped
% versions and optionally `string_escapes` mapping escapable strings (or
% multibyte UTF-8 characters) onto their escaped versions, returns a function
% that escapes a string. This function uses \pkg{lpeg} and is faster than
% `gsub`.
%  \begin{macrocode}
function util.escaper(char_escapes, string_escapes)
  local char_escapes_list = ""
  for i,_ in pairs(char_escapes) do
    char_escapes_list = char_escapes_list .. i
  end
  local escapable = S(char_escapes_list) / char_escapes
  if string_escapes then
    for k,v in pairs(string_escapes) do
      escapable = P(k) / v + escapable
    end
  end
  local escape_string = Cs((escapable + any)^0)
  return function(s)
    return lpegmatch(escape_string, s)
  end
end
%    \end{macrocode}
% \subsubsection{The \TeX{} writer}
% \blindtext
%
% Creates a new \TeX{} writer, where `options` is a table with options.
%  \begin{macrocode}
M.writer = {}
function M.writer.new(options)
  local self = {}
  local options = options or {}
%    \end{macrocode}
% A space character.
%  \begin{macrocode}
  self.space = " "
%    \end{macrocode}
% The plain text block formatter.
%  \begin{macrocode}
  function self.plain(s)
    return s
  end
%    \end{macrocode}
% The paragraph formatter.
%  \begin{macrocode}
  function self.paragraph(s)
    return s
  end
%    \end{macrocode}
% Line breaks for use between block elements.
%  \begin{macrocode}
  self.interblocksep = "\n\n"
%    \end{macrocode}
% A line break.
%  \begin{macrocode}
  self.linebreak = "\\\\"
%    \end{macrocode}
% An ellipsis.
%  \begin{macrocode}
  self.ellipsis = "\\markdownEllipsis "
%    \end{macrocode}
% The horizontal rule.
%  \begin{macrocode}
  self.hrule = "\\markdownHorizontalRule "
%    \end{macrocode}
% A special character escaping function.
%  \begin{macrocode}
  self.escaped = {
     ["{"] = "\\{",
     ["}"] = "\\}",
     ["$"] = "\\$",
     ["%"] = "\\%",
     ["&"] = "\\&",
     ["_"] = "\\_",
     ["#"] = "\\#",
     ["^"] = "\\^{}",
     ["\\"] = "\\char92{}",
     ["~"] = "\\char126{}",
     ["|"] = "\\char124{}",
  }
  local escape = util.escaper(self.escaped)
  if options.hybrid then
    self.string = function(s) return s end
  else
    self.string = escape
  end
%    \end{macrocode}
% The inline verbatim code formatter.
%  \begin{macrocode}
  function self.code(s)
    return {"\\markdownCodeSpan{",escape(s),"}"}
  end
%    \end{macrocode}
% A formatter for a link with the text `label`, the URI `uri`, and the title
% `title`.
%  \begin{macrocode}
  function self.link(lab,src,tit)
    return {"\\markdownLink{",self.string(lab[1]),"}",
                          "{",self.string(src),"}",
                          "{",self.string(tit),"}"}
  end
%    \end{macrocode}
% A formatter for an image with the alternative text `label`, the source URI
% `src`, and the title `title`.
%  \begin{macrocode}
  function self.image(lab,src,tit)
    return {"\\markdownImage{",self.string(lab[1]),"}",
                           "{",self.string(src),"}",
                           "{",self.string(tit),"}"}
  end
%    \end{macrocode}
% The formatter for a bullet list with contents `items` (an array).  If `tight`
% is true, the list should have minimal spacing between items.
%  \begin{macrocode}
  local function ulitem(s)
    return {"\\markdownUlItem ",s}
  end

  function self.bulletlist(items,tight)
    local buffer = {}
    for _,item in ipairs(items) do
      buffer[#buffer + 1] = ulitem(item)
    end
    local contents = util.intersperse(buffer,"\n")
    if tight then
      return {"\\markdownUlBeginTight\n",contents,"\n\\markdownUlEndTight "}
    else
      return {"\\markdownUlBegin\n",contents,"\n\\markdownUlEnd "}
    end
  end
%    \end{macrocode}
% The formatter for an ordered list with contents `items` (an array). If
% `tight` is true, the list should have minimal spacing between items. If the
% optional number `startnum` is present, it should be used as the number of
% the first list item.
%  \begin{macrocode}
  local function olitem(s,num)
    if num ~= nil then
      return {"\\markdownOlItemWithNumber{",num,"} ",s}
    else
      return {"\\markdownOlItem ",s}
    end
  end

  function self.orderedlist(items,tight,startnum)
    local buffer = {}
    local num = startnum
    for _,item in ipairs(items) do
      buffer[#buffer + 1] = olitem(item,num)
      if num ~= nil then
        num = num + 1
      end
    end
    local contents = util.intersperse(buffer,"\n")
    if tight then
      return {"\\markdownOlBeginTight\n",contents,"\n\\markdownOlEndTight "}
    else
      return {"\\markdownOlBegin\n",contents,"\n\\markdownOlEnd "}
    end
  end
%    \end{macrocode}
% The formatter for a definition list. `items` is an array of tables, each of
% the form `{ term = t, definitions = defs, tight = tight }`, where `t` is a
% string and `defs` is an array of strings.  If `tight` is true, the list
% should have minimal spacing between items.
%  \begin{macrocode}
  local function dlitem(term,defs)
      return {"\\markdownDlItem{",term,"}\n",defs}
  end

  function self.definitionlist(items,tight)
    local buffer = {}
    for _,item in ipairs(items) do
      buffer[#buffer + 1] = dlitem(item.term,
        util.intersperse(item.definitions, self.interblocksep))
    end
    local contents = util.intersperse(buffer, self.containersep)
    if tight then
      return {"\\markdownDlBeginTight\n",contents,"\n\\markdownDlEndTight "}
    else
      return {"\\markdownDlBegin\n",contents,"\n\\markdownDlEnd "}
    end
  end
%    \end{macrocode}
% The emphasized text formatter.
%  \begin{macrocode}
  function self.emphasis(s)
    return {"\\markdownEmphasis{",s,"}"}
  end
%    \end{macrocode}
% The strongly emphasized text formatter.
%  \begin{macrocode}
  function self.strong(s)
    return {"\\markdownStrongEmphasis{",s,"}"}
  end
%    \end{macrocode}
% The block quotation formatter.
%  \begin{macrocode}
  function self.blockquote(s)
    return {"\\markdownBlockQuoteBegin\n",s,"\n\\markdownBlockQuoteEnd "}
  end
%    \end{macrocode}
% The block verbatim code formatter.
%  \begin{macrocode}
  local function pathname(file)
    if #options.cacheDir == 0 then
      return file
    else
      return options.cacheDir .. "/" .. file
    end
  end

  function self.verbatim(s)
    if options.verbatim then
      local name = pathname(md5.sumhexa(s) .. ".verbatim")
      local file = io.open(name, "r")
      if file == nil then -- If no cache entry exists, then create a new one.
        -- TODO: Cache autocleaning.
        local file = assert(io.open(name, "w"))
        assert(file:write(s))
        assert(file:close())
      end
      return {"\\markdownInputVerbatim{",name,"}"}
    else
      return {"\\markdownCodeBlockBegin\n",escape(s),"\\markdownCodeBlockEnd "}
    end
  end
%    \end{macrocode}
% The formatter of a header `s` at level `level`.
%  \begin{macrocode}
  function self.header(s,level)
    local cmd
    if level == 1 then
      cmd = "\\markdownHeaderOne"
    elseif level == 2 then
      cmd = "\\markdownHeaderTwo"
    elseif level == 3 then
      cmd = "\\markdownHeaderThree"
    elseif level == 4 then
      cmd = "\\markdownHeaderFour"
    elseif level == 5 then
      cmd = "\\markdownHeaderFive"
    elseif level == 6 then
      cmd = "\\markdownHeaderSix"
    else
      cmd = ""
    end
    return {cmd,"{",s,"}"}
  end
%    \end{macrocode}
% The footnote formatter.
%  \begin{macrocode}
  function self.note(contents)
    return {"\\markdownFootnote{",contents,"}"}
  end

  return self
end
%    \end{macrocode}
% 
% \subsubsection{Markdown Reader}
% \blindtext
% 
% Normalizes a markdown reference tag. (Turns it lowercase, and collapses any
% adjacent whitespace characters.)
%  \begin{macrocode}
local function normalize_tag(tag)
  return utf8.lower(gsub(util.rope_to_string(tag), "[ \n\r\t]+", " "))
end
%    \end{macrocode}
% Creates a new markdown parser, where `writer` is a writer and where `options`
% is a table with options. The return value is a converter function that
% converts a markdown string using `writer`, returning the parsed document.
% The converter assumes that the input has unix line endings (newline).
%  \begin{macrocode}
M.reader = {}
function M.reader.new(writer, options)
  local options = options or {}

  local expandtabs
  if options.preserveTabs then
    expandtabs = function(s) return s end
  else
    expandtabs = function(s)
                   if s:find("\t") then
                     return s:gsub("[^\n]*", util.expand_tabs_in_line)
                   else
                     return s
                   end
                 end
  end

  ------------------------------------------------------------------------------

  local syntax
  local blocks
  local inlines

  parse_blocks =
    function(str)
      local res = lpegmatch(blocks, str)
      if res == nil
        then error(format("parse_blocks failed on:\n%s", str:sub(1,20)))
        else return res
        end
    end

  parse_inlines =
    function(str)
      local res = lpegmatch(inlines, str)
      if res == nil
        then error(format("parse_inlines failed on:\n%s", str:sub(1,20)))
        else return res
        end
    end

  parse_inlines_no_link =
    function(str)
      local res = lpegmatch(inlines_no_link, str)
      if res == nil
        then error(format("parse_inlines_no_link failed on:\n%s", str:sub(1,20)))
        else return res
        end
    end
%    \end{macrocode}
% \paragraph{Generic Parsers}
%  \begin{macrocode}
  local percent                = P("%")
  local asterisk               = P("*")
  local dash                   = P("-")
  local plus                   = P("+")
  local underscore             = P("_")
  local period                 = P(".")
  local hash                   = P("#")
  local ampersand              = P("&")
  local backtick               = P("`")
  local less                   = P("<")
  local more                   = P(">")
  local space                  = P(" ")
  local squote                 = P("'")
  local dquote                 = P('"')
  local lparent                = P("(")
  local rparent                = P(")")
  local lbracket               = P("[")
  local rbracket               = P("]")
  local circumflex             = P("^")
  local slash                  = P("/")
  local equal                  = P("=")
  local colon                  = P(":")
  local semicolon              = P(";")
  local exclamation            = P("!")

  local digit                  = R("09")
  local hexdigit               = R("09","af","AF")
  local letter                 = R("AZ","az")
  local alphanumeric           = R("AZ","az","09")
  local keyword                = letter * alphanumeric^0

  local doubleasterisks        = P("**")
  local doubleunderscores      = P("__")
  local fourspaces             = P("    ")

  local any                    = P(1)
  local fail                   = any - 1
  local always                 = P("")

  local escapable              = S("\\`*_{}[]()+_.!#-~:^")
  local anyescaped             = P("\\") / "" * escapable
                               + any

  local tab                    = P("\t")
  local spacechar              = S("\t ")
  local spacing                = S(" \n\r\t")
  local newline                = P("\n")
  local nonspacechar           = any - spacing
  local tightblocksep          = P("\001")

  local specialchar
  if options.smartEllipses then
    specialchar                = S("*_`&[]!\\.")
  else
    specialchar                = S("*_`&[]!\\")
  end

  local normalchar             = any -
                                 (specialchar + spacing + tightblocksep)
  local optionalspace          = spacechar^0
  local spaces                 = spacechar^1
  local eof                    = - any
  local nonindentspace         = space^-3 * - spacechar
  local indent                 = space^-3 * tab
                               + fourspaces / ""
  local linechar               = P(1 - newline)

  local blankline              = optionalspace * newline / "\n"
  local blanklines             = blankline^0
  local skipblanklines         = (optionalspace * newline)^0
  local indentedline           = indent    /"" * C(linechar^1 * newline^-1)
  local optionallyindentedline = indent^-1 /"" * C(linechar^1 * newline^-1)
  local sp                     = spacing^0
  local spnl                   = optionalspace * (newline * optionalspace)^-1
  local line                   = linechar^0 * newline
                               + linechar^1 * eof
  local nonemptyline           = line - blankline

  local chunk = line * (optionallyindentedline - blankline)^0

  -- block followed by 0 or more optionally
  -- indented blocks with first line indented.
  local function indented_blocks(bl)
    return Cs( bl
             * (blankline^1 * indent * -blankline * bl)^0
             * blankline^1 )
  end
%    \end{macrocode}
% \paragraph{List Parsers}
%  \begin{macrocode}
  local bulletchar = C(plus + asterisk + dash)

  local bullet     = ( bulletchar * #spacing * (tab + space^-3)
                     + space * bulletchar * #spacing * (tab + space^-2)
                     + space * space * bulletchar * #spacing * (tab + space^-1)
                     + space * space * space * bulletchar * #spacing
                     ) * -bulletchar

  if options.hashEnumerators then
    dig = digit + hash
  else
    dig = digit
  end

  local enumerator = C(dig^3 * period) * #spacing
                   + C(dig^2 * period) * #spacing * (tab + space^1)
                   + C(dig * period) * #spacing * (tab + space^-2)
                   + space * C(dig^2 * period) * #spacing
                   + space * C(dig * period) * #spacing * (tab + space^-1)
                   + space * space * C(dig^1 * period) * #spacing
%    \end{macrocode}
% \paragraph{Code Span Parsers}
%  \begin{macrocode}
  local openticks   = Cg(backtick^1, "ticks")

  local function captures_equal_length(s,i,a,b)
    return #a == #b and i
  end

  local closeticks  = space^-1 *
                      Cmt(C(backtick^1) * Cb("ticks"), captures_equal_length)

  local intickschar = (any - S(" \n\r`"))
                    + (newline * -blankline)
                    + (space - closeticks)
                    + (backtick^1 - closeticks)

  local inticks     = openticks * space^-1 * C(intickschar^1) * closeticks
%    \end{macrocode}
% \paragraph{Tags and Links Parsers}
%  \begin{macrocode}
  local leader        = space^-3

  -- in balanced brackets, parentheses, quotes:
  local bracketed     = P{ lbracket
                         * ((anyescaped - (lbracket + rbracket + blankline^2)) + V(1))^0
                         * rbracket }

  local inparens      = P{ lparent
                         * ((anyescaped - (lparent + rparent + blankline^2)) + V(1))^0
                         * rparent }

  local squoted       = P{ squote * alphanumeric
                         * ((anyescaped - (squote + blankline^2)) + V(1))^0
                         * squote }

  local dquoted       = P{ dquote * alphanumeric
                         * ((anyescaped - (dquote + blankline^2)) + V(1))^0
                         * dquote }

  -- bracketed 'tag' for markdown links, allowing nested brackets:
  local tag           = lbracket
                      * Cs((alphanumeric^1
                           + bracketed
                           + inticks
                           + (anyescaped - (rbracket + blankline^2)))^0)
                      * rbracket

  -- url for markdown links, allowing balanced parentheses:
  local url           = less * Cs((anyescaped-more)^0) * more
                      + Cs((inparens + (anyescaped-spacing-rparent))^1)

  -- quoted text possibly with nested quotes:
  local title_s       = squote  * Cs(((anyescaped-squote) + squoted)^0) * squote

  local title_d       = dquote  * Cs(((anyescaped-dquote) + dquoted)^0) * dquote

  local title_p       = lparent
                      * Cs((inparens + (anyescaped-rparent))^0)
                      * rparent

  local title         = title_d + title_s + title_p

  local optionaltitle = spnl * title * spacechar^0
                      + Cc("")
%    \end{macrocode}
% \paragraph{Footnotes}
%  \begin{macrocode}
  local rawnotes = {}

  local function strip_first_char(s)
    return s:sub(2)
  end

  -- like indirect_link
  local function lookup_note(ref)
    return function()
      local found = rawnotes[normalize_tag(ref)]
      if found then
        return writer.note(parse_blocks(found))
      else
        return {"[^", ref, "]"}
      end
    end
  end

  local function register_note(ref,rawnote)
    rawnotes[normalize_tag(ref)] = rawnote
    return ""
  end

  local RawNoteRef = #(lbracket * circumflex) * tag / strip_first_char

  local NoteRef    = RawNoteRef / lookup_note

  local NoteBlock

  if options.notes then
    NoteBlock = leader * RawNoteRef * colon * spnl * indented_blocks(chunk)
              / register_note
  else
    NoteBlock = fail
  end
%    \end{macrocode}
% \paragraph{Links and References Helpers}
%  \begin{macrocode}
  -- List of references defined in the document
  local references

  -- add a reference to the list
  local function register_link(tag,url,title)
      references[normalize_tag(tag)] = { url = url, title = title }
      return ""
  end

  -- parse a reference definition:  [foo]: /bar "title"
  local define_reference_parser =
    leader * tag * colon * spacechar^0 * url * optionaltitle * blankline^1

  -- lookup link reference and return either
  -- the link or nil and fallback text.
  local function lookup_reference(label,sps,tag)
      local tagpart
      if not tag then
          tag = label
          tagpart = ""
      elseif tag == "" then
          tag = label
          tagpart = "[]"
      else
          tagpart = {"[", parse_inlines(tag), "]"}
      end
      if sps then
        tagpart = {sps, tagpart}
      end
      local r = references[normalize_tag(tag)]
      if r then
        return r
      else
        return nil, {"[", parse_inlines(label), "]", tagpart}
      end
  end

  -- lookup link reference and return a link, if the reference is found,
  -- or a bracketed label otherwise.
  local function indirect_link(label,sps,tag)
    return function()
      local r,fallback = lookup_reference(label,sps,tag)
      if r then
        return writer.link(parse_inlines_no_link(label), r.url, r.title)
      else
        return fallback
      end
    end
  end

  -- lookup image reference and return an image, if the reference is found,
  -- or a bracketed label otherwise.
  local function indirect_image(label,sps,tag)
    return function()
      local r,fallback = lookup_reference(label,sps,tag)
      if r then
        return writer.image(writer.string(label), r.url, r.title)
      else
        return {"!", fallback}
      end
    end
  end
%    \end{macrocode}
% \paragraph{Inline Elements}
%  \begin{macrocode}
  local Inline    = V("Inline")

  local Str       = normalchar^1 / writer.string

  local Ellipsis  = P("...") / writer.ellipsis

  local Smart     = Ellipsis

  local Symbol    = (specialchar - tightblocksep) / writer.string

  local Code      = inticks / writer.code

  local bqstart      = more
  local headerstart  = hash
                     + (line * (equal^1 + dash^1) * optionalspace * newline)

  if options.requireBlankBeforeBlockquote then
    bqstart = fail
  end

  if options.requireBlankBeforeHeader then
    headerstart = fail
  end

  local Endline   = newline * -( -- newline, but not before...
                        blankline -- paragraph break
                      + tightblocksep  -- nested list
                      + eof       -- end of document
                      + bqstart
                      + headerstart
                    ) * spacechar^0 / writer.space

  local Space     = spacechar^2 * Endline / writer.linebreak
                  + spacechar^1 * Endline^-1 * eof / ""
                  + spacechar^1 * Endline^-1 * optionalspace / writer.space

  -- parse many p between starter and ender
  local function between(p, starter, ender)
      local ender2 = B(nonspacechar) * ender
      return (starter * #nonspacechar * Ct(p * (p - ender2)^0) * ender2)
  end

  local Strong = ( between(Inline, doubleasterisks, doubleasterisks)
                 + between(Inline, doubleunderscores, doubleunderscores)
                 ) / writer.strong

  local Emph   = ( between(Inline, asterisk, asterisk)
                 + between(Inline, underscore, underscore)
                 ) / writer.emphasis

  local urlchar = anyescaped - newline - more

  local AutoLinkUrl   = less
                      * C(alphanumeric^1 * P("://") * urlchar^1)
                      * more
                      / function(url) return writer.link(writer.string(url),url) end

  local AutoLinkEmail = less
                      * C((alphanumeric + S("-._+"))^1 * P("@") * urlchar^1)
                      * more
                      / function(email) return writer.link(writer.string(email),"mailto:"..email) end

  local DirectLink    = (tag / parse_inlines_no_link)  -- no links inside links
                      * spnl
                      * lparent
                      * (url + Cc(""))  -- link can be empty [foo]()
                      * optionaltitle
                      * rparent
                      / writer.link

  local IndirectLink = tag * (C(spnl) * tag)^-1 / indirect_link

  -- parse a link or image (direct or indirect)
  local Link          = DirectLink + IndirectLink

  local DirectImage   = exclamation
                      * (tag / parse_inlines)
                      * spnl
                      * lparent
                      * (url + Cc(""))  -- link can be empty [foo]()
                      * optionaltitle
                      * rparent
                      / writer.image

  local IndirectImage  = exclamation * tag * (C(spnl) * tag)^-1 / indirect_image

  local Image         = DirectImage + IndirectImage

  -- avoid parsing long strings of * or _ as emph/strong
  local UlOrStarLine  = asterisk^4 + underscore^4 / writer.string

  local EscapedChar   = S("\\") * C(escapable) / writer.string
%    \end{macrocode}
% \paragraph{Block Elements}
%  \begin{macrocode}
  local Block          = V("Block")

  local Verbatim       = Cs( (blanklines
                           * ((indentedline - blankline))^1)^1
                           ) / expandtabs / writer.verbatim

  -- strip off leading > and indents, and run through blocks
  local Blockquote     = Cs((
            ((leader * more * space^-1)/"" * linechar^0 * newline)^1
          * (-blankline * linechar^1 * newline)^0
          * blankline^0
          )^1) / parse_blocks / writer.blockquote

  local function lineof(c)
      return (leader * (P(c) * optionalspace)^3 * newline * blankline^1)
  end

  local HorizontalRule = ( lineof(asterisk)
                         + lineof(dash)
                         + lineof(underscore)
                         ) / writer.hrule

  local Reference      = define_reference_parser / register_link

  local Paragraph      = nonindentspace * Ct(Inline^1) * newline
                       * ( blankline^1
                         + #hash
                         + #(leader * more * space^-1)
                         )
                       / writer.paragraph

  local Plain          = nonindentspace * Ct(Inline^1) / writer.plain
%    \end{macrocode}
% \paragraph{Lists}
%  \begin{macrocode}
  local starter = bullet + enumerator

  -- we use \001 as a separator between a tight list item and a
  -- nested list under it.
  local NestedList            = Cs((optionallyindentedline - starter)^1)
                              / function(a) return "\001"..a end

  local ListBlockLine         = optionallyindentedline
                                - blankline - (indent^-1 * starter)

  local ListBlock             = line * ListBlockLine^0

  local ListContinuationBlock = blanklines * (indent / "") * ListBlock

  local function TightListItem(starter)
      return -HorizontalRule
             * (Cs(starter / "" * ListBlock * NestedList^-1) / parse_blocks)
             * -(blanklines * indent)
  end

  local function LooseListItem(starter)
      return -HorizontalRule
             * Cs( starter / "" * ListBlock * Cc("\n")
               * (NestedList + ListContinuationBlock^0)
               * (blanklines / "\n\n")
               ) / parse_blocks
  end

  local BulletList = ( Ct(TightListItem(bullet)^1)
                       * Cc(true) * skipblanklines * -bullet
                     + Ct(LooseListItem(bullet)^1)
                       * Cc(false) * skipblanklines ) / writer.bulletlist

  local function ordered_list(s,tight,startNumber)
    if options.startNumber then
      startNumber = tonumber(listtype) or 1  -- fallback for '#'
    else
      startNumber = nil
    end
    return writer.orderedlist(s,tight,startNumber)
  end

  local OrderedList = Cg(enumerator, "listtype") *
                      ( Ct(TightListItem(Cb("listtype")) * TightListItem(enumerator)^0)
                        * Cc(true) * skipblanklines * -enumerator
                      + Ct(LooseListItem(Cb("listtype")) * LooseListItem(enumerator)^0)
                        * Cc(false) * skipblanklines
                      ) * Cb("listtype") / ordered_list

  local defstartchar = S("~:")
  local defstart     = ( defstartchar * #spacing * (tab + space^-3)
                     + space * defstartchar * #spacing * (tab + space^-2)
                     + space * space * defstartchar * #spacing * (tab + space^-1)
                     + space * space * space * defstartchar * #spacing
                     )

  local dlchunk = Cs(line * (indentedline - blankline)^0)

  local function definition_list_item(term, defs, tight)
    return { term = parse_inlines(term), definitions = defs }
  end

  local DefinitionListItemLoose = C(line) * skipblanklines
                           * Ct((defstart * indented_blocks(dlchunk) / parse_blocks)^1)
                           * Cc(false)
                           / definition_list_item

  local DefinitionListItemTight = C(line)
                           * Ct((defstart * dlchunk / parse_blocks)^1)
                           * Cc(true)
                           / definition_list_item

  local DefinitionList =  ( Ct(DefinitionListItemLoose^1) * Cc(false)
                          +  Ct(DefinitionListItemTight^1)
                             * (skipblanklines * -DefinitionListItemLoose * Cc(true))
                          ) / writer.definitionlist
%    \end{macrocode}
% \paragraph{Blanks}
%  \begin{macrocode}
  local Blank          = blankline / ""
                       + NoteBlock
                       + Reference
                       + (tightblocksep / "\n")
%    \end{macrocode}
% \paragraph{Headers}
%  \begin{macrocode}
  -- parse Atx heading start and return level
  local HeadingStart = #hash * C(hash^-6) * -hash / length

  -- parse setext header ending and return level
  local HeadingLevel = equal^1 * Cc(1) + dash^1 * Cc(2)

  local function strip_atx_end(s)
    return s:gsub("[#%s]*\n$","")
  end

  -- parse atx header
  local AtxHeader = Cg(HeadingStart,"level")
                     * optionalspace
                     * (C(line) / strip_atx_end / parse_inlines)
                     * Cb("level")
                     / writer.header

  -- parse setext header
  local SetextHeader = #(line * S("=-"))
                     * Ct(line / parse_inlines)
                     * HeadingLevel
                     * optionalspace * newline
                     / writer.header
%    \end{macrocode}
% \paragraph{Syntax Specification}
%  \begin{macrocode}
  syntax =
    { "Blocks",

      Blocks                = Blank^0 *
                              Block^-1 *
                              (Blank^0 / function() return writer.interblocksep end * Block)^0 *
                              Blank^0 *
                              eof,

      Blank                 = Blank,

      Block                 = V("Blockquote")
                            + V("Verbatim")
                            + V("HorizontalRule")
                            + V("BulletList")
                            + V("OrderedList")
                            + V("Header")
                            + V("DefinitionList")
                            + V("Paragraph")
                            + V("Plain"),

      Blockquote            = Blockquote,
      Verbatim              = Verbatim,
      HorizontalRule        = HorizontalRule,
      BulletList            = BulletList,
      OrderedList           = OrderedList,
      Header                = AtxHeader + SetextHeader,
      DefinitionList        = DefinitionList,
      DisplayHtml           = DisplayHtml,
      Paragraph             = Paragraph,
      Plain                 = Plain,

      Inline                = V("Str")
                            + V("Space")
                            + V("Endline")
                            + V("UlOrStarLine")
                            + V("Strong")
                            + V("Emph")
                            + V("NoteRef")
                            + V("Link")
                            + V("Image")
                            + V("Code")
                            + V("AutoLinkUrl")
                            + V("AutoLinkEmail")
                            + V("EscapedChar")
                            + V("Smart")
                            + V("Symbol"),

      Str                   = Str,
      Space                 = Space,
      Endline               = Endline,
      UlOrStarLine          = UlOrStarLine,
      Strong                = Strong,
      Emph                  = Emph,
      NoteRef               = NoteRef,
      Link                  = Link,
      Image                 = Image,
      Code                  = Code,
      AutoLinkUrl           = AutoLinkUrl,
      AutoLinkEmail         = AutoLinkEmail,
      InlineHtml            = InlineHtml,
      HtmlEntity            = HtmlEntity,
      EscapedChar           = EscapedChar,
      Smart                 = Smart,
      Symbol                = Symbol,
    }

  if not options.definitionLists then
    syntax.DefinitionList = fail
  end

  if not options.notes then
    syntax.NoteRef = fail
  end

  if not options.smartEllipses then
    syntax.Smart = fail
  end

  blocks = Ct(syntax)

  local inlines_t = util.table_copy(syntax)
  inlines_t[1] = "Inlines"
  inlines_t.Inlines = Inline^0 * (spacing^0 * eof / "")
  inlines = Ct(inlines_t)

  inlines_no_link_t = util.table_copy(inlines_t)
  inlines_no_link_t.Link = fail
  inlines_no_link = Ct(inlines_no_link_t)
%    \end{macrocode}
% \paragraph{Exported Conversion Function}
%  \begin{macrocode}
  -- inp is a string; line endings are assumed to be LF (unix-style)
  -- and tabs are assumed to be expanded.
  return function(inp)
      references = {}
      return util.rope_to_string(parse_blocks(inp))
  end
end

return M
%    \end{macrocode}
% \blindtext
% \iffalse
%</lua>
% \fi
% 
% \iffalse
%<*tex>
% \fi\section{\TeX{} interface}
% \blindtext
%
% \subsection{User Interface}
% \blindtext
%
%  \begin{macrocode}
\def\markdownEllipsis{\markdownEllipsisPrototype}
\def\markdownCodeSpan{\markdownCodeSpanPrototype}
\def\markdownLink{\markdownLinkPrototype}
\def\markdownImage{\markdownImagePrototype}
\def\markdownUlBegin{\markdownUlBeginPrototype}
\def\markdownUlBeginTight{\markdownUlBeginTightPrototype}
\def\markdownUlItem{\markdownUlItemPrototype}
\def\markdownUlEnd{\markdownUlEndPrototype}
\def\markdownUlEndTight{\markdownUlEndTightPrototype}
\def\markdownOlBegin{\markdownOlBeginPrototype}
\def\markdownOlBeginTight{\markdownOlBeginTightPrototype}
\def\markdownOlItem{\markdownOlItemPrototype}
\def\markdownOlItemWithNumber{\markdownOlItemWithNumberPrototype}
\def\markdownOlEnd{\markdownOlEndPrototype}
\def\markdownOlEndTight{\markdownOlEndTightPrototype}
\def\markdownDlBegin{\markdownDlBeginPrototype}
\def\markdownDlBeginTight{\markdownDlBeginTightPrototype}
\def\markdownDlItem{\markdownDlItemPrototype}
\def\markdownDlEnd{\markdownDlEndPrototype}
\def\markdownDlEndTight{\markdownDlEndTightPrototype}
\def\markdownEmphasis{\markdownEmphasisPrototype}
\def\markdownStrongEmphasis{\markdownStrongEmphasisPrototype}
\def\markdownBlockQuoteBegin{\markdownBlockQuoteBeginPrototype}
\def\markdownBlockQuoteEnd{\markdownBlockQuoteEndPrototype}
\def\markdownCodeBlockBegin{\markdownCodeBlockBeginPrototype}
\def\markdownCodeBlockEnd{\markdownCodeBlockEndPrototype}
\def\markdownInputVerbatim{\markdownInputVerbatimPrototype}
\def\markdownHeaderOne{\markdownHeaderOnePrototype}
\def\markdownHeaderTwo{\markdownHeaderTwoPrototype}
\def\markdownHeaderThree{\markdownHeaderThreePrototype}
\def\markdownHeaderFour{\markdownHeaderFourPrototype}
\def\markdownHeaderFive{\markdownHeaderFivePrototype}
\def\markdownHeaderSix{\markdownHeaderSixPrototype}
\def\markdownHorizontalRule{\markdownHorizontalRulePrototype}
\def\markdownFootnote{\markdownFootnotePrototype}
%    \end{macrocode}
%
% \subsection{Package Interface}
% \blindtext
% 
%  \begin{macrocode}
\def\markdownEllipsisPrototype{...}
\def\markdownCodeSpanPrototype#1{#1}
\def\markdownLinkPrototype#1#2#3{#1}  % #1 = Label, #2 = Src, #3 = Title
\def\markdownImagePrototype#1#2#3{#1} % #1 = Label, #2 = Src, #3 = Title
\def\markdownUlBeginPrototype{}
\def\markdownUlBeginTightPrototype{}
\def\markdownUlItemPrototype{}
\def\markdownUlEndPrototype{}
\def\markdownUlEndTightPrototype{}
\def\markdownOlBeginPrototype{}
\def\markdownOlBeginTightPrototype{}
\def\markdownOlItemPrototype{}
\def\markdownOlItemWithNumberPrototype#1{}
\def\markdownOlEndPrototype{}
\def\markdownOlEndTightPrototype{}
\def\markdownDlBeginPrototype{}
\def\markdownDlBeginTightPrototype{}
\def\markdownDlItemPrototype#1{#1}
\def\markdownDlEndPrototype{}
\def\markdownDlEndTightPrototype{}
\def\markdownEmphasisPrototype#1{#1}
\def\markdownStrongEmphasisPrototype#1{#1}
\def\markdownBlockQuoteBeginPrototype{}
\def\markdownBlockQuoteEndPrototype{}
\def\markdownCodeBlockBeginPrototype{}
\def\markdownCodeBlockEndPrototype{}
\def\markdownInputVerbatimPrototype#1{\input#1\relax}
\def\markdownHeaderOnePrototype#1{#1}
\def\markdownHeaderTwoPrototype#1{#1}
\def\markdownHeaderThreePrototype#1{#1}
\def\markdownHeaderFourPrototype#1{#1}
\def\markdownHeaderFivePrototype#1{#1}
\def\markdownHeaderSixPrototype#1{#1}
\def\markdownHorizontalRulePrototype{}
\def\markdownFootnotePrototype#1{#1}
%    \end{macrocode}
% \iffalse
%</tex>
% \fi
%
% \iffalse
%<*latex>
% \fi\section{\LaTeX{} interface}
% \blindtext
%
% \iffalse
%</latex>
% \fi
%
% \iffalse
%<*context>
% \fi\section{\Hologo{ConTeXt} interface}
% \blindtext
%
% \iffalse
%</context>
% \fi
